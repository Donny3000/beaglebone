/*
 * i2c-mpu9150.c
 *
 *  Created on: Apr 4, 2014
 *      Author: Donald R. Poole, Jr.
 */

#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <rtdm/rtdm_driver.h>

#include "mpu9150.h"
#include "mpu9150-drv.h"
#include "mpu9150-irq.h"

#define DEVICE_NAME     "MPU-9150"
#define DRIVER_NAME     "mpu9150_driver"
#define PERIPHERAL_NAME "Invensense MPU-9150 9-axis IMU"
#define SUBCLASS         4711

// Variable to hold the initialization state.
static int is_irq_initialized = 0;
static int is_initialized = 0;
struct i2c_client *mpu9150_device = NULL;
EXPORT_SYMBOL_GPL(mpu9150_device);

/**
* The structure of the buffer
*
*/
typedef struct buffer_s {
	int size;
	char data[1024];
} buffer_t;

/**
* The global buffer
*
*/
buffer_t buffer;

/**
* The global semaphore
*
*/
rtdm_sem_t sem;

/*
 *   Begin the I2C Helper Functions
 */

int wakeup_mpu9150(const struct i2c_client *mpu9150)
{
	int retval, curVal;

	printk(KERN_INFO "I2C-MPU9150: Waking up MPU-9150 device...\n");
	if((curVal = i2c_smbus_read_byte_data(mpu9150, MPU9150_PWR_MGMT_1)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to read Power Management 1 register value.\n");
		return curVal;
	}

	// Set the sleep bit to 1 to put the mpu9150 into low power mode
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_PWR_MGMT_1, (curVal & 0xFF) & ~(1 << 6))) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to wake-up the MPU9150.\n");
		return retval;
	}

	return 0;
}

int sleep_mpu9150(const struct i2c_client *mpu9150)
{
	int retval, curVal;

	printk(KERN_INFO "I2C-MPU9150: Putting MPU-9150 device into low-power mode.\n");
	if((curVal = i2c_smbus_read_byte_data(mpu9150, MPU9150_PWR_MGMT_1)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to read Power Management 1 register value.\n");
		return curVal;
	}

	// Set the sleep bit to 1 to put the mpu9150 into low power mode
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_PWR_MGMT_1, (curVal & 0xFF) | (1 << 6))) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to put MPU9150 into low-power mode\n");
		return retval;
	}

	return 0;
}

/*****************************************************************************
 *            Begin the initialization of the MPU9150 device                 *
 *****************************************************************************/

int init_mpu9150_device(const struct i2c_client *mpu9150)
{
	int retval;
	/*
	* Sample Rate Divider: Address 0x19
	*
	* Description:
	* ------------
	* This register specifies the divider from the gyroscope output rate used
	* to generate the Sample Rate for the MPU-9150.
	*
	* The sensor register output,FIFO output and DMP sampling are all based on
	* the Sample Rate. The Sample Rate is generated by dividing the gyroscope
	* output rate by SMPLRT_DIV:
	* Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
	* where Gyroscope Output Rate = 8kHz when the DLPF is disabled
	* (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).
	*
	* Note: The accelerometer output rate is 1kHz. This means that for a
	* Sample Rate greater than 1kHz, the same accelerometer sample may be
	* output to the FIFO, DMP, and sensor registers more than once.
	*
	* Usage: We will set the value to 8 to get a sensor sample rate of 1kHz.
	* Since the accelerometer sample rate is 1kHz, we will set the sample rate
	* of the other data to 1kHz too.
	*/
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_SMPLRT_DIV, 0x07)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 sample rate divider.\n");
		return retval;
	}

	/*
	 * Configuration: Address: 0x1A
	 *
	 * Description:
	 * ------------
	 * This register configures the external Frame Synchronization (FSYNC) pin
	 * sampling and the Digital Low Pass Filter (DLPF) setting for both the
	 * gyroscopes and accelerometers.
	 *
	 * An external signal connected to the FSYNC pin can be sampled by
	 * configuring EXT_SYNC_SET.
	 *
	 * Signal changes to the FSYNC pin are latched so that short strobes may be
	 * captured. The latched FSYNC signal will be sampled at the Sampling Rate,
	 * as defined in register 25. After sampling, the latch will reset to the
	 * current FSYNC signal state.
	 *
	 * The sampled value will be reported in place of the least significant bit
	 * in a sensor data register determined by the value of EXT_SYNC_SET
	 * according to the following table.
	 *
	 *                  -------------------------------------
	 *                  | EXT_SYNC_SET | FSYNC Bit Location |
	 *                  -------------------------------------
	 *                  |       0      | Input Disabled     |
	 *                  |       1      | TEMP_OUT_L[0]      |
	 *                  |       2      | GYRO_XOUT_L[0]     |
	 *                  |       3      | GYRO_YOUT_L[0]     |
	 *                  |       4      | GYRO_ZOUT_L[0]     |
	 *                  |       5      | ACCEL_XOUT_L[0]    |
	 *                  |       6      | ACCEL_YOUT_L[0]    |
	 *                  |       7      | ACCEL_ZOUT_L[0]    |
	 *                  -------------------------------------
	 *
	 * The DLPF is configured by DLPF_CFG. The accelerometer and gyroscope are
	 * filtered according to the value of DLPF_CFG as shown in the table below.
	 *
	 * |----------------------------------------------------------------------------|
	 * | DLPF_CFG |      Accelerometer      |                Gyroscope              |
	 * |          |       (Fs = 1kHz)       |                                       |
	 * |          |-------------------------|---------------------------------------|
	 * |          | Bandwidth    | Delay    | Bandwidth    | Delay    | Fs (kHz)    |
	 * |          | (Hz)         | (ms)     | (Hz)         | (ms)     |             |
	 * |----------------------------------------------------------------------------|
	 * |    0     |     260      |     0    |      256     |   0.98   |      8      |
	 * |    1     |     184      |     0    |      188     |   0.98   |      1      |
	 * |    2     |     94       |     0    |      98      |   0.98   |      1      |
	 * |    3     |     44       |     0    |      42      |   0.98   |      1      |
	 * |    4     |     21       |     0    |      20      |   0.98   |      1      |
	 * |    5     |     10       |     0    |      10      |   0.98   |      1      |
	 * |    6     |     5        |     0    |      5       |   0.98   |      1      |
	 * |    7     |        RESERVED         |         RESERVED        |      8      |
	 * |----------------------------------------------------------------------------|
	 *
	 * Bit 7 and bit 6 are reserved.
	 *
	 * Parameters:
	 * -----------
	 * EXT_FSYNC_SET   3-bit unsigned value. Configures the FSYNC pin sampling.
	 * DLPF_CFG        3-bit unsigned value. Configures the DLPF setting.
	 *
	 * Usage: Disable FSYNC input and the Digital Low-pass Filter to get the
	 * highest bandwidth and lowest time delay.
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_CONFIG, 0x00)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 configuration.\n");
		return retval;
	}

	/*
	 * Gyroscope Configuration: Address 0x1B
	 *
	 * Description:
	 * ------------
	 * This register is used to trigger gyroscope self-test and configure the
	 * gyroscopes’ full scale range.
	 *
	 * The self-test for each gyroscope axis can be activated by controlling
	 * the XG_ST, YG_ST, and ZG_ST bits of this register. Self-test for each
	 * axis may be performed independently or all at the same time. Please
	 * refer to registers 13 – 16 for further information on gyroscope
	 * self-test.
	 *
	 * This register is used to configure the gyroscopes’ full scale range.
	 *
	 * FS_SEL selects the full scale range of the gyroscope outputs according to the following table.
	 *
	 *                    |----------------------------|
	 *                    | FS_SEL | Full Scale Range  |
	 *                    |--------|-------------------|
	 *                    |    0   | +/-250 degrees/s  |
	 *                    |    1   | +/-500 degrees/s  |
	 *                    |    2   | +/-1000 degrees/s |
	 *                    |    3   | +/-2000 degrees/s |
	 *                    |--------|-------------------|
	 *
	 * Bits 7 through 5 and 2 through 0 are reserved.
	 *
	 * Parameters:
	 * -----------
	 * FS_SEL 2-bit unsigned value. Selects the full scale range of gyroscopes.
	 *
	 * Usage: Set the range to +/- 1000 degrees/s
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_GYRO_CONFIG, 0x10)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 Gyroscope configuration.\n");
		return retval;
	}

	/*
	 * Accelerometer Configuration: Address 0x1C
	 *
	 * Description:
	 * ------------
	 * This register is used to trigger accelerometer self-test and configure
	 * the accelerometer full scale range.
	 *
	 * The self-test for each accelerometer axis can be activated by
	 * controlling the XA_ST, YA_ST, and ZA_ST bits of this register. Self-test
	 * for each axis may be performed independently or all at the same time.
	 * Please refer to registers 13 – 16 for further information on
	 * accelerometer self-test.
	 *
	 * AFS_SEL selects the full scale range of the accelerometer outputs
	 * according to the following table.
	 *
	 * Usage: We are setting the range to +/-8g
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_ACCEL_CONFIG, 0x10)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 Accelerometer configuration.\n");
		return retval;
	}

	/*
	 * FIFO Enable: Address: 0x23
	 *
	 * Description:
	 * ------------
	 * This register determines which sensor measurements are loaded into the
	 * FIFO buffer.
	 *
	 * Data stored inside the sensor data registers (Registers 59 to 96) will
	 * be loaded into the FIFO buffer if a sensor’s respective FIFO_EN bit is
	 * set to 1 in this register.
	 *
	 * When a sensor’s FIFO_EN bit is enabled in this register, data from the
	 * sensor data registers will be loaded into the FIFO buffer. The sensors
	 * are sampled at the Sample Rate as defined in Register 25. For further
	 * information regarding sensor data registers, please refer to Registers
	 * 59 to 96.
	 *
	 * When an external Slave’s corresponding FIFO_EN bit (SLVx_FIFO_EN, where
	 * x=0, 1, or 2) is set to 1, the data stored in its corresponding data
	 * registers (EXT_SENS_DATA registers, Registers 73 to 96) will be written
	 * into the FIFO buffer at the Sample Rate. EXT_SENS_DATA register
	 * association with I2C Slaves is determined by the I2C_SLVx_CTRL registers
	 * (where x=0, 1, or 2; Registers 39, 42, and 45). For information
	 * regarding EXT_SENS_DATA registers, please refer to Registers 73 to 96.
	 *
	 * Note that the corresponding FIFO_EN bit (SLV3_FIFO_EN) is found in
	 * I2C_MST_CTRL (Register 36). Also note that Slave 4 behaves in a
	 * different manner compared to Slaves 0-3. Please refer to Registers 49 to
	 * 53 for further information regarding Slave 4 usage.
	 *
	 * Parameters:
	 * -----------
	 * TEMP_FIFO_EN   When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L
	 *                (Registers 65 and 66) to be written into the FIFO buffer.
	 * XG_FIFO_EN     When set to 1, this bit enables GYRO_XOUT_H and
	 *                GYRO_XOUT_L (Registers 67 and 68) to be written into the
	 *                FIFO buffer.
	 * YG_FIFO_EN     When set to 1, this bit enables GYRO_YOUT_H and
	 *                GYRO_YOUT_L (Registers 69 and 70) to be written into the
	 *                FIFO buffer.
	 * ZG_FIFO_EN     When set to 1, this bit enables GYRO_ZOUT_H and
	 *                GYRO_ZOUT_L (Registers 71 and 72) to be written into the
	 *                FIFO buffer.
	 * ACCEL_FIFO_EN  When set to 1, this bit enables ACCEL_XOUT_H,
	 *                ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H,
	 *                and ACCEL_ZOUT_L (Registers 59 to 64) to be written into
	 *                the FIFO buffer.
	 * SLV2_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
	 *                (Registers 73 to 96) associated with Slave 2 to be
	 *                written into the FIFO buffer.
	 * SLV1_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
	 *                (Registers 73 to 96) associated with Slave 1 to be written
	 *                into the FIFO buffer.
	 * SLV0_FIFO_EN   When set to 1, this bit enables EXT_SENS_DATA registers
	 *                (Registers 73 to 96) associated with Slave 0 to be
	 *                written into the FIFO buffer.
	 *
	 * ￼Note: For further information regarding the association of
	 * EXT_SENS_DATA registers to particular slave devices, please refer to
	 * Registers 73 to 96.
	 *
	 * Usage: We are enable the Temp, Gyro & Accelerometer Sensor data
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_FIFO_EN, 0xF8)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 FIFO configuration.\n");
		return retval;
	}

	/*
	 * Interrupt Pin / Bypass Enable Configuration: Address 0x37
	 *
	 * Description:
	 * ------------
	 * This register configures the behavior of the interrupt signals at the
	 * INT pins. This register is also used to enable the FSYNC Pin to be used
	 * as an interrupt to the host application processor, as well as to enable
	 * Bypass Mode on the I2C Master. This bit also enables the clock output.
	 *
	 * FSYNC_INT_EN enables the FSYNC pin to be used as an interrupt to the
	 * host application processor. A transition to the active level specified
	 * in FSYNC_INT_LEVEL will trigger an interrupt. The status of this
	 * interrupt is read from the PASS_THROUGH bit in the I2C Master Status
	 * Register (Register 54).
	 *
	 * When I2C_BYPASS_EN is equal to 1 and I2C_MST_EN (Register 106 bit[5])
	 * is equal to 0, the host application processor will be able to directly
	 * access the auxiliary I2C bus of the MPU-9150. When this bit is equal to
	 * 0, the host application processor will not be able to directly access
	 * the auxiliary I2C bus of the MPU-9150 regardless of the state of
	 * I2C_MST_EN.
	 *
	 * For further information regarding Bypass Mode, please refer to Section
	 * 7.12 and 7.14 of the MPU- 9150 Product Specification document.
	 *
	 * Parameters:
	 * -----------
	 * NT_LEVEL         When this bit is equal to 0, the logic level for the
	 *                  INT pin is active high.
	 *                  When this bit is equal to 1, the logic level for the
	 *                  INT pin is active low.
	 *
	 * INT_OPEN         When this bit is equal to 0, the INT pin is configured
	 *                  as push-pull.
	 *                  When this bit is equal to 1, the INT pin is configured
	 *                  as open drain.
	 *
	 * LATCH_INT_EN     When this bit is equal to 0, the INT pin emits a 50us
	 *                  long pulse.
	 *                  When this bit is equal to 1, the INT pin is held high
	 *                  until the interrupt is cleared.
	 *
	 * INT_RD_CLEAR     When this bit is equal to 0, interrupt status bits are
	 *                  cleared only by reading INT_STATUS (Register 58)
	 *                  When this bit is equal to 1, interrupt status bits are
	 *                  cleared on any read operation.
	 *
	 * FSYNC_INT_LEVEL  When this bit is equal to 0, the logic level for the
	 *                  FSYNC pin (when used as an interrupt to the host
	 *                  processor) is active high.
	 *                  When this bit is equal to 1, the logic level for the
	 *                  FSYNC pin (when used as an interrupt to the host
	 *                  processor) is active low.
	 *
	 * FSYNC_INT_EN     When equal to 0, this bit disables the FSYNC pin from
	 *                  causing an interrupt to the host processor.
	 *                  When equal to 1, this bit enables the FSYNC pin to be
	 *                  used as an interrupt to the host processor.
	 *
	 * I2C_BYPASS_EN    When this bit is equal to 1 and I2C_MST_EN (Register
	 *                  106 bit[5]) is equal to 0, the host application
	 *                  processor will be able to directly access the auxiliary
	 *                  I2C bus of the MPU-9150.
	 *                  When this bit is equal to 0, the host application
	 *                  processor will not be able to directly access the
	 *                  auxiliary I2C bus of the MPU-9150 regardless of the
	 *                  state of I2C_MST_EN (Register 106 bit[5]).
	 *
	 * Usage: We will enable I2C bypass, disable FSYNC interrupt, enable
	 * interrupt any read clear, latch the interrupt line until cleared,
	 * push-pull output and active high.
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_INT_PIN_CFG, 0x12)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 interrupt pin configuration.\n");
		return retval;
	}

	/*
	 * Interrupt Enable: Address 0x38
	 *
	 * Description:
	 * ------------
	 * This register enables interrupt generation by interrupt sources.
	 *
	 * For information regarding the interrupt status for of each interrupt
	 * generation source, please refer to Register 58. Further information
	 * regarding I2C Master interrupt generation can be found in Register 54.
	 *
	 * Bits 7, 5, 2 and 1 are reserved.
	 *
	 * Parameters:
	 * -----------
	 * IFO_OFLOW_EN    When set to 1, this bit enables a FIFO buffer overflow
	 *                 to generate an interrupt.
	 * I2C_MST_INT_EN  When set to 1, this bit enables any of the I2C Master
	 *                 interrupt sources to generate an interrupt.
	 * DATA_RDY_EN     When set to 1, this bit enables the Data Ready interrupt
	 *                 which occurs each time a write operation to all of the
	 *                 sensor registers has been completed.
	 *
	 * Usage: We want to enable the FIFO OFLOW_EN and DATA_RDY_EN interrupts.
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_INT_ENABLE, 0x19)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 interrupt enable configuration.\n");
		return retval;
	}

	/*
	 * User Control: Address 0x6A
	 *
	 * Description:
	 * ------------
	 * This register allows the user to enable and disable the FIFO buffer, I2C
	 * Master Mode, and primary I2C interface. The FIFO buffer, I2C Master,
	 * sensor signal paths and sensor registers can also be reset using this
	 * register.
	 *
	 * When I2C_MST_EN is set to 1, I2C Master Mode is enabled. In this mode,
	 * the MPU-9150 acts as the I2C Master to the external sensor slave devices
	 * on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary
	 * I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary
	 * I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode.
	 * For further information regarding Bypass Mode, please refer to Register
	 * 55.
	 *
	 * Always write 0 to I2C_IF_DIS for the MPU-9150.
	 *
	 * When the reset bits (FIFO_RESET, I2C_MST_RESET, and SIG_COND_RESET) are
	 * set to 1, these reset bits will trigger a reset and then clear to 0.
	 * Bits 7 and 3 are reserved.
	 *
	 * Parameters:
	 * -----------
	 * FIFO_EN         When set to 1, this bit enables FIFO operations.
	 *                 When this bit is cleared to 0, the FIFO buffer is
	 *                 disabled.
	 *                 The FIFO buffer cannot be written to or read
	 *                 from while disabled.
	 * I2C_MST_EN      When set to 1, this bit enables I2C Master Mode.
	 *                 When this bit is cleared to 0, the auxiliary I2C bus
	 *                 lines (AUX_DA and AUX_CL) are logically driven by the
	 *                 primary I2C bus (SDA and SCL).
	 * I2C_IF_DIS      Always write this bit as zero.
	 * FIFO_RESET      This bit resets the FIFO buffer when set to 1 while
	 *                 FIFO_EN equals 0. This bit automatically clears to 0
	 *                 after the reset has been triggered.
	 * I2C_MST_RESET   This bit resets the I2C Master when set to 1 while
	 *                 I2C_MST_EN equals 0.
	 *                 This bit automatically clears to 0 after the reset has
	 *                 been triggered.
	 * SIG_COND_RESET  When set to 1, this bit resets the signal paths for all
	 *                 sensors (gyroscopes, accelerometers, and temperature
	 *                 sensor). This operation will also clear the sensor
	 *                 registers. This bit automatically clears to 0 after the
	 *                 reset has been triggered.
	 *                 When resetting only the signal path (and not the sensor
	 *                 registers), please use Register 104, SIGNAL_PATH_RESET.
	 *
	 * Usage: Enable the FIFO, Disable I2C Master Mode.
	 */
	if((retval = i2c_smbus_write_byte_data(mpu9150, MPU9150_USER_CTRL, 0x40)) < 0)
	{
		printk(KERN_ERR "I2C-MPU9150: Failed to set MPU9150 user control configuration.\n");
		return retval;
	}

	is_initialized = 1;

	printk(KERN_INFO "I2C-MPU9150: Device initialization complete!\n");

	return 0;
}

static int find_mpu9150_device(struct i2c_client *device)
{
	int address = device->addr;

	if(address == MPU9150_I2C_ADDRESS || address == (MPU9150_I2C_ADDRESS+1))
	{
		if( !mpu9150_device )
		{
			printk(KERN_INFO KERN_INFO "I2C-MPU9150:%s: Found Invensense MPU-9150 Device at I2C address 0x%X\n", __func__, address);
			if((mpu9150_device = (struct i2c_client *) kzalloc(sizeof(struct i2c_client), GFP_KERNEL)) == NULL)
			{
				printk(KERN_ERR "I2C-MPU9150: Failed to allocate memory for MPU9150 I2C device!\n");
				return -ENOMEM;
			}
			*mpu9150_device = *device;
		}

		return 0;
	}

	return -ENODEV;
}

static int preinit_mpu9150(const struct i2c_client *mpu9150)
{
	int retval;

	if( !is_irq_initialized )
	{
		if((retval = init_mpu9150_irq()) < 0)
			return retval;
		else
			is_irq_initialized = 1;
	}

	// Initialize the device now that it has been found and not already initialized.
	if( !is_initialized )
	{
		if((retval = init_mpu9150_device(mpu9150)) < 0)
			return retval;
	}

	return 0;
}


/*****************************************************************************
 *              Begin the I2C driver callback functions                      *
 *****************************************************************************/

static int mpu9150_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
{
	int retval;
	const char *name = NULL;

	if((retval = find_mpu9150_device( client )) < 0)
		return retval;

	// If the mpu9150 device was found, proceed with setting up the board info.
	name = "mpu9150";
	strlcpy(info->type, name, I2C_NAME_SIZE);

	// Then, setup the IRQ and the device configuration
	return preinit_mpu9150( client );
}

static int mpu9150_i2c_probe(struct i2c_client *client,
		const struct i2c_device_id *id)
{
	int retval;

	if(!i2c_check_functionality(client->adapter,
			I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
			I2C_FUNC_SMBUS_I2C_BLOCK))
	{
		printk(KERN_ERR "I2C-MPU9150:%s: Needed I2C functionality is not supported\n", __func__);
		return -ENODEV;
	}

	// Check the address of the client to see if we are an MPU-9150 device
	if((retval = find_mpu9150_device( client )) <= 0)
		return retval;

	// If it's a mpu9150 device, then setup the IRQ and device configuration.
	return preinit_mpu9150( client );
}

static int mpu9150_i2c_remove(struct i2c_client *client)
{
	int retval;

	if( mpu9150_device )
	{
		// Put the mpu9150 into a low-power state
		if((retval = sleep_mpu9150(mpu9150_device)) < 0)
			return retval;

		kfree( mpu9150_device );
		mpu9150_device = NULL;
	}

	return 0;
}

#ifdef CONFIG_PM
static int mpu9150_i2c_suspend(struct i2c_client *client, pm_message_t msg)
{
	//struct mpu9150_device_t *dev __attribute__((__unused__)) = i2c_get_clientdata( client );
	return sleep_mpu9150( client );
}

static int mpu9150_i2c_resume(struct i2c_client *client)
{
	//struct mpu9150_device_t *dev __attribute__((__unused__)) = i2c_get_clientdata( client );
	return wakeup_mpu9150( client );
}
#else

#define mpu9150_i2c_suspend NULL
#define mpu9150_i2c_resume  NULL

#endif

/*
 *   Begin the RTDM Driver Callbacks
 */

/**
* Open the device
*
* This function is called when the device shall be opened.
*
*/
static int mpu9150_rtdm_open(struct rtdm_dev_context *context,
rtdm_user_info_t * user_info, int oflags)
{
	return 0;
}

/**
* Close the device
*
* This function is called when the device shall be closed.
*
*/
static int mpu9150_rtdm_close(struct rtdm_dev_context *context,
rtdm_user_info_t * user_info)
{
	return 0;
}

/**
* Read from the device
*
* This function is called when the device is read in realtime context.
*
*/
static ssize_t mpu9150_rtdm_read_rt(struct rtdm_dev_context *context,
rtdm_user_info_t * user_info, void *buf,
size_t nbyte)
{
	int ret, size;

	/* take the semaphore */
	rtdm_sem_down( &sem );

	/* read the kernel buffer and sent it to user space */
	size = (buffer.size > nbyte) ? nbyte : buffer.size;
	ret = rtdm_safe_copy_to_user(user_info, buf, buffer.data, size);

	/* if an error has occured, send it to user */
	if( ret )
		return ret;

	/* clean the kernel buffer */
	buffer.size = 0;

	return size;
}

/**
* Write in the device
*
* This function is called when the device is written in realtime context.
*
*/
static ssize_t mpu9150_rtdm_write_rt(struct rtdm_dev_context *context,
rtdm_user_info_t * user_info,
const void *buf, size_t nbyte)
{
	int ret;

	/* write the user buffer in the kernel buffer */
	buffer.size = (nbyte > SIZE_MAX) ? SIZE_MAX : nbyte;
	ret = rtdm_safe_copy_from_user(user_info, buffer.data, buf, buffer.size);

	/* if an error has occured, send it to user */
	if( ret )
		return ret;

	/* release the semaphore */
	rtdm_sem_up( &sem );

	return nbyte;
}

/*****************************************************************************
 *            Begin Declaring the I2C Drivers Setup Structure                *
 *****************************************************************************/
// Tell the I2C framework which chips we support
static const struct i2c_device_id mpu9150_i2c_id[] = {
	{ "i2c-mpu9150", 0 },
	{}
};

// List of valid address for the MPU9150
static unsigned short mpu9150_i2c_addresses[] = {
	0x68, 0x69
};
MODULE_DEVICE_TABLE(i2c, mpu9150_i2c_id);

// Structure representing the device driver for a particular class of
// I2C/SMBus slave devices.
static struct i2c_driver mpu9150_i2c_driver = {
	.probe    = mpu9150_i2c_probe,
	.remove   = mpu9150_i2c_remove,
	.id_table = mpu9150_i2c_id,
	.driver   = {
		.name = "i2c-mpu9150",
	},

	/* Device auto-detection */
	.class        = I2C_CLASS_HWMON,
	.detect       = mpu9150_i2c_detect,
	.address_list = mpu9150_i2c_addresses,

	//.shutdown     = mpu9150_shutdown,  /* optional */
	.suspend      = mpu9150_i2c_suspend, /* optional */
	.resume       = mpu9150_i2c_resume,  /* optional */
	//.command      = mpu9150_command,   /* optional, deprecated */
};

/*****************************************************************************
 *            Begin Declaring the RTDM Driver Setup Structure                *
 *****************************************************************************/
static struct rtdm_device mpu9150_driver = {
	.struct_version = RTDM_DEVICE_STRUCT_VER,

	.device_flags = RTDM_NAMED_DEVICE,
	.context_size = 0,
	.device_name = DEVICE_NAME,

	.open_nrt = mpu9150_rtdm_open,
	.open_rt = mpu9150_rtdm_open,

	.ops = {
		.close_nrt = mpu9150_rtdm_close,
		.close_rt = mpu9150_rtdm_close,
		.read_rt = mpu9150_rtdm_read_rt,
		.write_rt = mpu9150_rtdm_write_rt,
	},

	.device_class = RTDM_CLASS_EXPERIMENTAL,
	.device_sub_class = SUBCLASS,
	.profile_version = 1,
	.driver_name = DRIVER_NAME,
	.driver_version = RTDM_DRIVER_VER(1, 0, 0),
	.peripheral_name = PERIPHERAL_NAME,
	.provider_name = "Donald R. Poole, Jr.",
	.proc_name = mpu9150_driver.device_name,
};

static int __init mpu9150_i2c_init_driver(void)
{
	int retval;
	if((retval = rtdm_dev_register(&mpu9150_driver)) < 0)
		return retval;

	return i2c_add_driver( &mpu9150_i2c_driver );
}

static void __exit mpu9150_i2c_exit_driver(void)
{
	if( mpu9150_device )
		sleep_mpu9150( mpu9150_device );

	cleanup_mpu9150_irq();
	i2c_del_driver( &mpu9150_i2c_driver );
	// Poll at 1kHs for pending users
	rtdm_dev_unregister(&mpu9150_driver, 1000);
}

module_init( mpu9150_i2c_init_driver );
module_exit( mpu9150_i2c_exit_driver );

MODULE_AUTHOR("Donald R. Poole, Jr.");
MODULE_DESCRIPTION("Invensense MPU-9150 9-Axis IMU I2C Xenomai RTDM Client Driver");
MODULE_LICENSE("GPL");
