<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: HAL.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>HAL.</h1>  </div>
</div>
<div class="contents">

<p>Generic Adeos-based hardware abstraction layer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="arm_2hal_8c.html">hal.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for ARM. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2hal_8c.html">hal.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for the Blackfin architecture. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2hal_8c.html">hal.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Generic Real-Time HAL. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nios2_2hal_8c.html">hal.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for the NIOS2 architecture. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="powerpc_2hal_8c.html">hal.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for PowerPC. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sh_2hal_8c.html">hal.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for the SuperH architecture. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal-common_8c.html">hal-common.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__32_8c.html">hal_32.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__64_8c.html">hal_64.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Adeos-based Real-Time Abstraction Layer for x86_64. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="smi_8c.html">smi.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>SMI workaround for x86. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6">rthal_timer_request</a> (void(*tick_handler)(void), void(*mode_emul)(enum clock_event_mode mode, struct clock_event_device *cdev), int(*tick_emul)(unsigned long delay, struct clock_event_device *cdev), int cpu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grab the hardware timer.  <a href="#ga174a498bd8ee10a2279a9f79b9823bf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga1ff77e4ea7ed60ba6a1b1a61a513058d">rthal_timer_release</a> (int cpu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the hardware timer.  <a href="#ga1ff77e4ea7ed60ba6a1b1a61a513058d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gae84c63d8728c72e9374da3a86df14d64">rthal_irq_host_request</a> (unsigned irq, rthal_irq_host_handler_t handler, char *name, void *dev_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a shared Linux interrupt handler.  <a href="#gae84c63d8728c72e9374da3a86df14d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga80403d346662fcc3c960f12e4d5b8e09">rthal_irq_host_release</a> (unsigned irq, void *dev_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall a shared Linux interrupt handler.  <a href="#ga80403d346662fcc3c960f12e4d5b8e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable</a> (unsigned irq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an interrupt source.  <a href="#ga306c0dcb88589f6a84f9b9d3304c4e8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga615e2795b5a080f9155bf2f9f29e0b3f">rthal_irq_disable</a> (unsigned irq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an interrupt source.  <a href="#ga615e2795b5a080f9155bf2f9f29e0b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request</a> (unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a real-time interrupt handler.  <a href="#gaadf0f98059a5bf1caddda9dd48d51f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release</a> (unsigned irq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall a real-time interrupt handler.  <a href="#gad7d90c5882463a1d36b7a0ad74a9d4ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rthal_trap_handler_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga3f868180536815c231983781afef99c4">rthal_trap_catch</a> (rthal_trap_handler_t handler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Installs a fault handler.  <a href="#ga3f868180536815c231983781afef99c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169">rthal_apc_alloc</a> (const char *name, void(*handler)(void *cookie), void *cookie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an APC slot.  <a href="#gafb91722da28118853a09b1a0d98dd169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gaf11636f94b0a6913241679d84265eba6">rthal_apc_free</a> (int apc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases an APC slot.  <a href="#gaf11636f94b0a6913241679d84265eba6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Generic Adeos-based hardware abstraction layer. </p>
<p>x86_64-specific HAL services.</p>
<p>i386-specific HAL services.</p>
<p>SuperH-specific HAL services.</p>
<p>PowerPC-specific HAL services.</p>
<p>NIOS2-specific HAL services.</p>
<p>Blackfin-specific HAL services.</p>
<p>ARM-specific HAL services. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafb91722da28118853a09b1a0d98dd169"></a><!-- doxytag: member="hal.c::rthal_apc_alloc" ref="gafb91722da28118853a09b1a0d98dd169" args="(const char *name, void(*handler)(void *cookie), void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_apc_alloc </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an APC slot. </p>
<p>APC is the acronym for Asynchronous Procedure Call, a mean by which activities from the Xenomai domain can schedule deferred invocations of handlers to be run into the Linux domain, as soon as possible when the Linux kernel gets back in control. Up to BITS_PER_LONG APC slots can be active at any point in time. APC support is built upon Adeos's virtual interrupt support.</p>
<p>The HAL guarantees that any Linux kernel service which would be callable from a regular Linux interrupt handler is also available to APC handlers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a symbolic name identifying the APC which will get reported through the /proc/xenomai/apc interface. Passing NULL to create an anonymous APC is allowed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the fault handler to call upon exception condition. The handle will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the HAL will pass to the APC handler as its sole argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an valid APC id. is returned upon success, or a negative error code otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>handler</em> is invalid.</li>
</ul>
<ul>
<li>-EBUSY is returned if no more APC slots are available.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf11636f94b0a6913241679d84265eba6"></a><!-- doxytag: member="hal.c::rthal_apc_free" ref="gaf11636f94b0a6913241679d84265eba6" args="(int apc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_apc_free </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>apc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases an APC slot. </p>
<p>This service deallocates an APC slot obtained by <a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169" title="Allocate an APC slot.">rthal_apc_alloc()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>apc</em>&nbsp;</td><td>The APC id. to release, as returned by a successful call to the <a class="el" href="group__hal.html#gafb91722da28118853a09b1a0d98dd169" title="Allocate an APC slot.">rthal_apc_alloc()</a> service.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga615e2795b5a080f9155bf2f9f29e0b3f"></a><!-- doxytag: member="hal.c::rthal_irq_disable" ref="ga615e2795b5a080f9155bf2f9f29e0b3f" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_disable </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable an interrupt source. </p>
<p>Disables an interrupt source at PIC level. After this call has returned, no more IRQs from the given source will be allowed, until the latter is enabled again using <a class="el" href="group__hal.html#ga306c0dcb88589f6a84f9b9d3304c4e8e" title="Enable an interrupt source.">rthal_irq_enable()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to disable. This value is architecture-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga306c0dcb88589f6a84f9b9d3304c4e8e"></a><!-- doxytag: member="hal.c::rthal_irq_enable" ref="ga306c0dcb88589f6a84f9b9d3304c4e8e" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_enable </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable an interrupt source. </p>
<p>Enables an interrupt source at PIC level. Since Adeos masks and acknowledges the associated interrupt source upon IRQ receipt, this action is usually needed whenever the HAL handler does not propagate the IRQ event to the Linux domain, thus preventing the regular Linux interrupt handling code from re-enabling said source. After this call has returned, IRQs from the given source will be enabled again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to enable. This value is architecture-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga80403d346662fcc3c960f12e4d5b8e09"></a><!-- doxytag: member="hal.c::rthal_irq_host_release" ref="ga80403d346662fcc3c960f12e4d5b8e09" args="(unsigned irq, void *dev_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_host_release </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dev_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uninstall a shared Linux interrupt handler. </p>
<p>Uninstalls a shared interrupt handler from the Linux domain for the given interrupt source. The handler is removed from the existing list of Linux handlers for this interrupt source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to detach the shared handler from. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is a valid device id, identical in essence to the one requested by the free_irq() service provided by the Linux kernel. This value will be used to locate the handler to remove from the chain of existing Linux handlers for the given interrupt source. This parameter must match the device id. passed to <a class="el" href="group__hal.html#gae84c63d8728c72e9374da3a86df14d64" title="Install a shared Linux interrupt handler.">rthal_irq_host_request()</a> for the same handler instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae84c63d8728c72e9374da3a86df14d64"></a><!-- doxytag: member="hal.c::rthal_irq_host_request" ref="gae84c63d8728c72e9374da3a86df14d64" args="(unsigned irq, rthal_irq_host_handler_t handler, char *name, void *dev_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_host_request </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_host_handler_t&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dev_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a shared Linux interrupt handler. </p>
<p>Installs a shared interrupt handler in the Linux domain for the given interrupt source. The handler is appended to the existing list of Linux handlers for this interrupt source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to attach the shared handler to. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, as part of the chain of existing regular Linux handlers for this interrupt source. The handler prototype is the same as the one required by the request_irq() service provided by the Linux kernel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a symbolic name identifying the handler which will get reported through the /proc/interrupts interface.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is a unique device id, identical in essence to the one requested by the request_irq() service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad7d90c5882463a1d36b7a0ad74a9d4ff"></a><!-- doxytag: member="hal.c::rthal_irq_release" ref="gad7d90c5882463a1d36b7a0ad74a9d4ff" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_release </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uninstall a real-time interrupt handler. </p>
<p>Uninstalls an interrupt handler previously attached using the <a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20" title="Install a real-time interrupt handler.">rthal_irq_request()</a> service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel to uninstall a handler from. This value is architecture-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

<p>Referenced by <a class="el" href="group__hal.html#ga1ff77e4ea7ed60ba6a1b1a61a513058d">rthal_timer_release()</a>.</p>

</div>
</div>
<a class="anchor" id="gaadf0f98059a5bf1caddda9dd48d51f20"></a><!-- doxytag: member="hal.c::rthal_irq_request" ref="gaadf0f98059a5bf1caddda9dd48d51f20" args="(unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_request </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_handler_t&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_ackfn_t&nbsp;</td>
          <td class="paramname"> <em>ackfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a real-time interrupt handler. </p>
<p>Installs an interrupt handler for the specified IRQ line by requesting the appropriate Adeos virtualization service. The handler is invoked by Adeos on behalf of the Xenomai domain context. Once installed, the HAL interrupt handler will be called prior to the regular Linux handler for the same interrupt source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel to install a handler on. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, and will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ackfn</em>&nbsp;</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the one provided by Adeos. Only very specific situations actually require to override the default Adeos setting for this parameter, like having to acknowledge non-standard PIC hardware. If <em>ackfn</em> is NULL, the default Adeos routine will be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the HAL will pass to the interrupt handler as its sole argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if an interrupt handler is already installed. <a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff" title="Uninstall a real-time interrupt handler.">rthal_irq_release()</a> must be issued first before a handler is installed anew.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li>
</ul>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

<p>Referenced by <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6">rthal_timer_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ff77e4ea7ed60ba6a1b1a61a513058d"></a><!-- doxytag: member="hal.c::rthal_timer_release" ref="ga1ff77e4ea7ed60ba6a1b1a61a513058d" args="(int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rthal_timer_release </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the hardware timer. </p>
<p>Releases the hardware timer, thus reverting the effect of a previous call to <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a>. In case the timer hardware is shared with Linux, a periodic setup suitable for the Linux kernel will be reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU number the timer was grabbed from.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

<p>References <a class="el" href="group__hal.html#gad7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release()</a>.</p>

</div>
</div>
<a class="anchor" id="ga174a498bd8ee10a2279a9f79b9823bf6"></a><!-- doxytag: member="hal.c::rthal_timer_request" ref="ga174a498bd8ee10a2279a9f79b9823bf6" args="(void(*tick_handler)(void), void(*mode_emul)(enum clock_event_mode mode, struct clock_event_device *cdev), int(*tick_emul)(unsigned long delay, struct clock_event_device *cdev), int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_timer_request </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>tick_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(enum clock_event_mode mode, struct clock_event_device *cdev)&nbsp;</td>
          <td class="paramname"> <em>mode_emul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(unsigned long delay, struct clock_event_device *cdev)&nbsp;</td>
          <td class="paramname"> <em>tick_emul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grab the hardware timer. </p>
<p><a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a> grabs and tunes the hardware timer in oneshot mode in order to clock the master time base.</p>
<p>A user-defined routine is registered as the clock tick handler. This handler will always be invoked on behalf of the Xenomai domain for each incoming tick.</p>
<p>Hooks for emulating oneshot mode for the tick device are accepted when CONFIG_GENERIC_CLOCKEVENTS is defined for the host kernel. Host tick emulation is a way to share the clockchip hardware between Linux and Xenomai, when the former provides support for oneshot timing (i.e. high resolution timers and no-HZ scheduler ticking).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tick_handler</em>&nbsp;</td><td>The address of the Xenomai tick handler which will process each incoming tick.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode_emul</em>&nbsp;</td><td>The optional address of a callback to be invoked upon mode switch of the host tick device, notified by the Linux kernel. This parameter is only considered whenever CONFIG_GENERIC_CLOCKEVENTS is defined.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tick_emul</em>&nbsp;</td><td>The optional address of a callback to be invoked upon setup of the next shot date for the host tick device, notified by the Linux kernel. This parameter is only considered whenever CONFIG_GENERIC_CLOCKEVENTS is defined.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU number to grab the timer from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a positive value is returned on success, representing the duration of a Linux periodic tick expressed as a count of nanoseconds; zero should be returned when the Linux kernel does not undergo periodic timing on the given CPU (e.g. oneshot mode). Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the hardware timer has already been grabbed. <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a> must be issued before <a class="el" href="group__hal.html#ga174a498bd8ee10a2279a9f79b9823bf6" title="Grab the hardware timer.">rthal_timer_request()</a> is called again.</li>
</ul>
<ul>
<li>-ENODEV is returned if the hardware timer cannot be used. This situation may occur after the kernel disabled the timer due to invalid calibration results; in such a case, such hardware is unusable for any timing duties.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Linux domain context. </li>
</ul>

<p>References <a class="el" href="group__hal.html#gaadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f868180536815c231983781afef99c4"></a><!-- doxytag: member="hal.c::rthal_trap_catch" ref="ga3f868180536815c231983781afef99c4" args="(rthal_trap_handler_t handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_trap_catch </td>
          <td>(</td>
          <td class="paramtype">rthal_trap_handler_t&nbsp;</td>
          <td class="paramname"> <em>handler</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Installs a fault handler. </p>
<p>The HAL attempts to invoke a fault handler whenever an uncontrolled exception or fault is caught at machine level. This service allows to install a user-defined handler for such events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the fault handler to call upon exception condition. The handler is passed the address of the low-level information block describing the fault as passed by Adeos. Its layout is implementation-dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the fault handler previously installed.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Any domain context. </li>
</ul>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 10 2012 20:41:24 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
