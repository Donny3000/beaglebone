<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Message pipe services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Message pipe services.<br/>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Message pipe services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__pipe.png" border="0" alt="" usemap="#group____pipe"/>
<map name="group____pipe" id="group____pipe">
<area shape="rect" id="node2" href="group__native.html" title="Native Xenomai API." alt="" coords="7,5,159,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2pipe_8c.html">pipe.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file is part of the Xenomai project. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5">rt_pipe_create</a> (RT_PIPE *pipe, const char *name, int minor, size_t poolsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a message pipe.  <a href="#ga29521cc898afa0069963964955167aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga1d84976a1b9b668366261ca9b836b677">rt_pipe_delete</a> (RT_PIPE *pipe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a message pipe.  <a href="#ga1d84976a1b9b668366261ca9b836b677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive</a> (RT_PIPE *pipe, RT_PIPE_MSG **msgp, RTIME timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message from a pipe.  <a href="#ga731e5ef18007dcd58a9346bea66abbc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read</a> (RT_PIPE *pipe, void *buf, size_t size, RTIME timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a message from a pipe.  <a href="#ga62cb64807c2c843f8e8eebb2dc3a7d4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send</a> (RT_PIPE *pipe, RT_PIPE_MSG *msg, size_t size, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message through a pipe.  <a href="#gaf40b20cad1dcd7bedcda72beaa16c057"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write</a> (RT_PIPE *pipe, const void *buf, size_t size, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a message to a pipe.  <a href="#ga12f801963d0db6aa60bc6cf92f65697a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#gad8edc920499d2c5c5d821ee7b9fa2bcd">rt_pipe_stream</a> (RT_PIPE *pipe, const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream bytes to a pipe.  <a href="#gad8edc920499d2c5c5d821ee7b9fa2bcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RT_PIPE_MSG *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga40f294bf6254d2e1b66b8b6b400fc2e5">rt_pipe_alloc</a> (RT_PIPE *pipe, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a message pipe buffer.  <a href="#ga40f294bf6254d2e1b66b8b6b400fc2e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga8face1c57df99cf43b029b3e3b6a05c6">rt_pipe_free</a> (RT_PIPE *pipe, RT_PIPE_MSG *msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a message pipe buffer.  <a href="#ga8face1c57df99cf43b029b3e3b6a05c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#gab4d85ecda7675a75611500070c28b22e">rt_pipe_flush</a> (RT_PIPE *pipe, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the i/o queues associated with the kernel endpoint of a message pipe.  <a href="#gab4d85ecda7675a75611500070c28b22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#ga944600f54dc78a77badeda77f3af732d">rt_pipe_monitor</a> (RT_PIPE *pipe, int(*fn)(RT_PIPE *pipe, int event, long arg))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Monitor a message pipe asynchronously.  <a href="#ga944600f54dc78a77badeda77f3af732d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Message pipe services.</p>
<p>A message pipe is a two-way communication channel between Xenomai tasks and standard Linux processes using regular file I/O operations on a pseudo-device. Pipes can be operated in a message-oriented fashion so that message boundaries are preserved, and also in byte streaming mode from real-time to standard Linux processes for optimal throughput.</p>
<p>Xenomai tasks open their side of the pipe using the <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a> service; standard Linux processes do the same by opening one of the /dev/rtpN special devices, where N is the minor number agreed upon between both ends of each pipe. Additionally, named pipes are available through the registry support, which automatically creates a symbolic link from entries under /proc/xenomai/registry/native/pipes/ to the corresponding special device file. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga40f294bf6254d2e1b66b8b6b400fc2e5"></a><!-- doxytag: member="pipe.c::rt_pipe_alloc" ref="ga40f294bf6254d2e1b66b8b6b400fc2e5" args="(RT_PIPE *pipe, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RT_PIPE_MSG* rt_pipe_alloc </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a message pipe buffer. </p>
<p>This service allocates a message buffer from the pipe's heap which can be subsequently filled by the caller then passed to <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057" title="Send a message through a pipe.">rt_pipe_send()</a> for sending. The beginning of the available data area of <em>size</em> contiguous bytes is accessible from P_MSGPTR(msg).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The requested size in bytes of the buffer. This value should represent the size of the payload data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the allocated message buffer upon success, or NULL if the allocation fails.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__heap.html#gaaa8ae99881c9e6a4f8b56aa79f983bdb">xnheap_alloc()</a>.</p>

<p>Referenced by <a class="el" href="group__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga29521cc898afa0069963964955167aa5"></a><!-- doxytag: member="pipe.c::rt_pipe_create" ref="ga29521cc898afa0069963964955167aa5" args="(RT_PIPE *pipe, const char *name, int minor, size_t poolsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_create </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>poolsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a message pipe. </p>
<p>This service opens a bi-directional communication channel allowing data exchange between Xenomai tasks and standard Linux processes. Pipes natively preserve message boundaries, but can also be used in byte stream mode from Xenomai tasks to standard Linux processes.</p>
<p><a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a> always returns immediately, even if no Linux process has opened the associated special device file yet. On the contrary, the non real-time side could block upon attempt to open the special device file until <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a> is issued on the same pipe from a Xenomai task, unless O_NONBLOCK has been specified to the open(2) system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The address of a pipe descriptor Xenomai will use to store the pipe-related data. This descriptor must always be valid while the pipe is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the message pipe. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created pipe.</td></tr>
  </table>
  </dd>
</dl>
<p>Named pipes are supported through the use of the registry. When the registry support is enabled, passing a valid <em>name</em> parameter when creating a message pipe subsequently allows standard Linux processes to follow a symbolic link from /proc/xenomai/registry/pipes/<em>name</em> in order to reach the associated special device (i.e. /dev/rtp*), so that the specific <em>minor</em> information does not need to be known from those processes for opening the proper device file. In such a case, both sides of the pipe only need to agree upon a symbolic name to refer to the same data path, which is especially useful whenever the <em>minor</em> number is picked up dynamically using an adaptive algorithm, such as passing P_MINOR_AUTO as <em>minor</em> value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>The minor number of the device associated with the pipe. Passing P_MINOR_AUTO causes the minor number to be auto-allocated. In such a case, the <em>name</em> parameter must be valid so that user-space processes may subsequently follow the symbolic link that will be automatically created from /proc/xenomai/registry/pipes/<em>name</em> to the allocated pipe device entry (i.e. /dev/rtp*).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poolsize</em>&nbsp;</td><td>Specifies the size of a dedicated buffer pool for the pipe. Passing 0 means that all message allocations for this pipe are performed on the system heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the pipe, or if not enough memory could be obtained from the selected buffer pool for allocating the internal streaming buffer.</li>
</ul>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li>
</ul>
<ul>
<li>-ENODEV is returned if <em>minor</em> is different from P_MINOR_AUTO and is not a valid minor number for the pipe special device either (i.e. /dev/rtp*).</li>
</ul>
<ul>
<li>-EBUSY is returned if <em>minor</em> is already open.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pipe.html#ga1d84976a1b9b668366261ca9b836b677">rt_pipe_delete()</a>, <a class="el" href="group__heap.html#gaaa8ae99881c9e6a4f8b56aa79f983bdb">xnheap_alloc()</a>, <a class="el" href="group__heap.html#gaf33cea7788162687767ca7c8c149f6ab">xnheap_destroy()</a>, <a class="el" href="group__heap.html#gad65beaf18754ad1f85c479eaf9219042">xnheap_init()</a>, <a class="el" href="group__heap.html#gabfa339d98cfd2271b5d80d64b20c0e2c">xnheap_set_label()</a>, and <a class="el" href="group__registry.html#ga28aefd9be7367aa495753142005e1d5a">xnregistry_enter()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d84976a1b9b668366261ca9b836b677"></a><!-- doxytag: member="pipe.c::rt_pipe_delete" ref="ga1d84976a1b9b668366261ca9b836b677" args="(RT_PIPE *pipe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_delete </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a message pipe. </p>
<p>This service deletes a pipe previously created by <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a>. Data pending for transmission to non real-time processes are lost.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF can be returned if <em>pipe</em> is scrambled.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__registry.html#ga477bb20ccb4bcf87c343aca8e58f9ef9">xnregistry_remove()</a>.</p>

<p>Referenced by <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5">rt_pipe_create()</a>.</p>

</div>
</div>
<a class="anchor" id="gab4d85ecda7675a75611500070c28b22e"></a><!-- doxytag: member="pipe.c::rt_pipe_flush" ref="gab4d85ecda7675a75611500070c28b22e" args="(RT_PIPE *pipe, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_flush </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush the i/o queues associated with the kernel endpoint of a message pipe. </p>
<p>This service flushes all data pending for consumption by the remote side in user-space for the given message pipe. Upon success, no data remains to be read from the remote side of the connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to flush.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A mask indicating which queues need to be flushed; the following flags may be combined in a single flush request:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNPIPE_OFLUSH causes the output queue to be flushed (i.e. unread data sent from the real-time endpoint in kernel-space to the non real-time endpoint in user-space will be discarded). This is equivalent to calling ioctl(pipefd, XNPIPEIOC_OFLUSH, 0) from user-space.</li>
</ul>
<ul>
<li>XNPIPE_IFLUSH causes the input queue to be flushed (i.e. unread data sent from the non real-time endpoint in user-space to the real-time endpoint in kernel-space will be discarded). This is equivalent to calling ioctl(pipefd, XNPIPEIOC_IFLUSH, 0) from user-space.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga8face1c57df99cf43b029b3e3b6a05c6"></a><!-- doxytag: member="pipe.c::rt_pipe_free" ref="ga8face1c57df99cf43b029b3e3b6a05c6" args="(RT_PIPE *pipe, RT_PIPE_MSG *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_free </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_PIPE_MSG *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a message pipe buffer. </p>
<p>This service releases a message buffer returned by <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6" title="Receive a message from a pipe.">rt_pipe_receive()</a> to the pipe's heap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>The address of the message buffer to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL if <em>msg</em> is not a valid message buffer previously allocated by the <a class="el" href="group__pipe.html#ga40f294bf6254d2e1b66b8b6b400fc2e5" title="Allocate a message pipe buffer.">rt_pipe_alloc()</a> service.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__heap.html#ga5dc4305113cd272cfed62e20e2a12ae6">xnheap_free()</a>.</p>

<p>Referenced by <a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a>, and <a class="el" href="group__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga944600f54dc78a77badeda77f3af732d"></a><!-- doxytag: member="pipe.c::rt_pipe_monitor" ref="ga944600f54dc78a77badeda77f3af732d" args="(RT_PIPE *pipe, int(*fn)(RT_PIPE *pipe, int event, long arg))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_monitor </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(RT_PIPE *pipe, int event, long arg)&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Monitor a message pipe asynchronously. </p>
<p>This service registers a notifier callback that will be called upon specific events occurring on the channel. <a class="el" href="group__pipe.html#ga944600f54dc78a77badeda77f3af732d" title="Monitor a message pipe asynchronously.">rt_pipe_monitor()</a> is particularly useful to monitor a channel asynchronously while performing other tasks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to monitor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The notification handler. This user-provided routine will be passed the address of the message pipe descriptor receiving the event, the event code, and an optional argument. Four events are currently defined:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>P_EVENT_INPUT is sent when the user-space endpoint writes to the pipe, which means that some input is pending for the kernel-based endpoint. The argument is the size of the incoming message.</li>
</ul>
<ul>
<li>P_EVENT_OUTPUT is sent when the user-space endpoint successfully reads a complete buffer from the pipe. The argument is the size of the outgoing message.</li>
</ul>
<ul>
<li>P_EVENT_CLOSE is sent when the user-space endpoint is closed. The argument is always 0.</li>
</ul>
<ul>
<li>P_EVENT_NOBUF is sent when no memory is available from the kernel pool to hold the message currently sent from the user-space endpoint. The argument is the size of the failed allocation. Upon return from the handler, the caller will block and retry until enough space is available from the pool; during that process, the handler might be called multiple times, each time a new attempt to get the required memory fails.</li>
</ul>
<p>The P_EVENT_INPUT and P_EVENT_OUTPUT events are fired on behalf of a fully atomic context; therefore, care must be taken to keep their overhead low. In those cases, the Xenomai services that may be called from the handler are restricted to the set allowed to a real-time interrupt handler.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga62cb64807c2c843f8e8eebb2dc3a7d4e"></a><!-- doxytag: member="pipe.c::rt_pipe_read" ref="ga62cb64807c2c843f8e8eebb2dc3a7d4e" args="(RT_PIPE *pipe, void *buf, size_t size, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_read </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a message from a pipe. </p>
<p>This service retrieves the next message written to the associated special device in user-space. <a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e" title="Read a message from a pipe.">rt_pipe_read()</a> always preserves message boundaries, which means that all data sent through the same write(2) operation to the special device will be gathered in a single message by this service. This services differs from <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6" title="Receive a message from a pipe.">rt_pipe_receive()</a> in that it copies back the payload data to a user-defined memory area, instead of returning a pointer to the internal message buffer holding such data.</p>
<p>Unless otherwise specified, the caller is blocked for a given amount of time if no data is immediately available on entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the read message contents.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The count of bytes from the received message to read up into <em>buf</em>. If <em>size</em> is lower than the actual message size, -ENOBUFS is returned since the incompletely received message would be lost. If <em>size</em> is zero, this call returns immediately with no other action.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing TM_INFINITE causes the caller to block indefinitely until some data is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no data is available on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of read bytes copied to the <em>buf</em> is returned upon success. Otherwise:</dd></dl>
<ul>
<li>0 is returned if the peer closed the channel while <a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e" title="Read a message from a pipe.">rt_pipe_read()</a> was reading from it. There is no way to distinguish this situation from an empty message return using <a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e" title="Read a message from a pipe.">rt_pipe_read()</a>. One should rather call <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6" title="Receive a message from a pipe.">rt_pipe_receive()</a> whenever this information is required.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no data is available within the specified amount of time.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no data is immediately available on entry.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<ul>
<li>-ENOBUFS is returned if <em>size</em> is not large enough to collect the message data.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="group__pipe.html#ga8face1c57df99cf43b029b3e3b6a05c6">rt_pipe_free()</a>, and <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a>.</p>

</div>
</div>
<a class="anchor" id="ga731e5ef18007dcd58a9346bea66abbc6"></a><!-- doxytag: member="pipe.c::rt_pipe_receive" ref="ga731e5ef18007dcd58a9346bea66abbc6" args="(RT_PIPE *pipe, RT_PIPE_MSG **msgp, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_receive </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_PIPE_MSG **&nbsp;</td>
          <td class="paramname"> <em>msgp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a message from a pipe. </p>
<p>This service retrieves the next message written to the associated special device in user-space. <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6" title="Receive a message from a pipe.">rt_pipe_receive()</a> always preserves message boundaries, which means that all data sent through the same write(2) operation to the special device will be gathered in a single message by this service. This service differs from <a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e" title="Read a message from a pipe.">rt_pipe_read()</a> in that it returns a pointer to the internal buffer holding the message, which improves performances by saving a data copy to a user-provided buffer, especially when large messages are involved.</p>
<p>Unless otherwise specified, the caller is blocked for a given amount of time if no data is immediately available on entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to receive from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msgp</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the address of the received message. Once consumed, the message space should be freed using <a class="el" href="group__pipe.html#ga8face1c57df99cf43b029b3e3b6a05c6" title="Free a message pipe buffer.">rt_pipe_free()</a>. The application code can retrieve the actual data and size carried by the message by respectively using the P_MSGPTR() and P_MSGSIZE() macros. *msgp is set to NULL and zero is returned to the caller, in case the peer closed the channel while <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6" title="Receive a message from a pipe.">rt_pipe_receive()</a> was reading from it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing TM_INFINITE causes the caller to block indefinitely until some data is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no data is available on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of read bytes available from the received message is returned upon success; this value will be equal to P_MSGSIZE(*msgp). Otherwise:</dd></dl>
<ul>
<li>0 is returned and *msgp is set to NULL if the peer closed the channel while <a class="el" href="group__pipe.html#ga731e5ef18007dcd58a9346bea66abbc6" title="Receive a message from a pipe.">rt_pipe_receive()</a> was reading from it. This is to be distinguished from an empty message return, where *msgp points to a valid - albeit empty - message block (i.e. P_MSGSIZE(*msgp) == 0).</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no data is available within the specified amount of time.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no data is immediately available on entry.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li>
</ul>
<ul>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>Referenced by <a class="el" href="group__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf40b20cad1dcd7bedcda72beaa16c057"></a><!-- doxytag: member="pipe.c::rt_pipe_send" ref="gaf40b20cad1dcd7bedcda72beaa16c057" args="(RT_PIPE *pipe, RT_PIPE_MSG *msg, size_t size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_send </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_PIPE_MSG *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a message through a pipe. </p>
<p>This service writes a complete message to be received from the associated special device. <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057" title="Send a message through a pipe.">rt_pipe_send()</a> always preserves message boundaries, which means that all data sent through a single call of this service will be gathered in a single read(2) operation from the special device. This service differs from <a class="el" href="group__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a" title="Write a message to a pipe.">rt_pipe_write()</a> in that it accepts a canned message buffer, instead of a pointer to the raw data to be sent. This call is useful whenever the caller wants to prepare the message contents separately from its sending, which does not require to have all the data to be sent available at once but allows for incremental updates of the message, and also saves a message copy, since <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057" title="Send a message through a pipe.">rt_pipe_send()</a> deals internally with message buffers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to send to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>The address of the message to be sent. The message space must have been allocated using the <a class="el" href="group__pipe.html#ga40f294bf6254d2e1b66b8b6b400fc2e5" title="Allocate a message pipe buffer.">rt_pipe_alloc()</a> service. Once passed to <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057" title="Send a message through a pipe.">rt_pipe_send()</a>, the memory pointed to by <em>msg</em> is no more under the control of the application code and thus should not be referenced by it anymore; deallocation of this memory will be automatically handled as needed. As a special exception, <em>msg</em> can be NULL and will not be dereferenced if <em>size</em> is zero.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the message (payload data only). Zero is a valid value, in which case the service returns immediately without sending any message. This parameter allows you to actually send less data than you reserved using the <a class="el" href="group__pipe.html#ga40f294bf6254d2e1b66b8b6b400fc2e5" title="Allocate a message pipe buffer.">rt_pipe_alloc()</a> service, which may be the case if you did not know how much space you needed at the time of allocation. In all other cases it may be more convenient to just pass P_MSGSIZE(msg).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>P_URGENT causes the message to be prepended to the output queue, ensuring a LIFO ordering.</li>
</ul>
<ul>
<li>P_NORMAL causes the message to be appended to the output queue, ensuring a FIFO ordering.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Upon success, this service returns <em>size</em>. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: possible.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Writing data to a pipe before any peer has opened the associated special device is allowed. The output will be buffered until then, only restricted by the available memory in the relevant buffer pool (see <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a>). </dd></dl>

<p>Referenced by <a class="el" href="group__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8edc920499d2c5c5d821ee7b9fa2bcd"></a><!-- doxytag: member="pipe.c::rt_pipe_stream" ref="gad8edc920499d2c5c5d821ee7b9fa2bcd" args="(RT_PIPE *pipe, const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_stream </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stream bytes to a pipe. </p>
<p>This service writes a sequence of bytes to be received from the associated special device. Unlike <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057" title="Send a message through a pipe.">rt_pipe_send()</a>, this service does not preserve message boundaries. Instead, an internal buffer is filled on the fly with the data, which will be consumed as soon as the receiver wakes up.</p>
<p>Data buffers sent by the <a class="el" href="group__pipe.html#gad8edc920499d2c5c5d821ee7b9fa2bcd" title="Stream bytes to a pipe.">rt_pipe_stream()</a> service are always transmitted in FIFO order (i.e. P_NORMAL mode).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before transmission.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the buffer. Zero is a valid value, in which case the service returns immediately without buffering any data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes sent upon success; this value may be lower than <em>size</em>, depending on the available space in the internal buffer. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<ul>
<li>-ENOSYS is returned if the byte streaming mode has been disabled at configuration time by nullifying the size of the pipe buffer (see CONFIG_XENO_OPT_NATIVE_PIPE_BUFSZ).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Writing data to a pipe before any peer has opened the associated special device is allowed. The output will be buffered until then, only restricted by the available memory in the relevant buffer pool (see <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga12f801963d0db6aa60bc6cf92f65697a"></a><!-- doxytag: member="pipe.c::rt_pipe_write" ref="ga12f801963d0db6aa60bc6cf92f65697a" args="(RT_PIPE *pipe, const void *buf, size_t size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_write </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a message to a pipe. </p>
<p>This service writes a complete message to be received from the associated special device. <a class="el" href="group__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a" title="Write a message to a pipe.">rt_pipe_write()</a> always preserves message boundaries, which means that all data sent through a single call of this service will be gathered in a single read(2) operation from the special device. This service differs from <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057" title="Send a message through a pipe.">rt_pipe_send()</a> in that it accepts a pointer to the raw data to be sent, instead of a canned message buffer. This call is useful whenever the caller does not need to prepare the message contents separately from its sending.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before transmission.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the message (payload data only). Zero is a valid value, in which case the service returns immediately without sending any message.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>P_URGENT causes the message to be prepended to the output queue, ensuring a LIFO ordering.</li>
</ul>
<ul>
<li>P_NORMAL causes the message to be appended to the output queue, ensuring a FIFO ordering.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Upon success, this service returns <em>size</em>. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li>
</ul>
<ul>
<li>-ENOMEM is returned if not enough buffer space is available to complete the operation.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Writing data to a pipe before any peer has opened the associated special device is allowed. The output will be buffered until then, only restricted by the available memory in the relevant buffer pool (see <a class="el" href="group__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe.">rt_pipe_create()</a>). </dd></dl>

<p>References <a class="el" href="group__pipe.html#ga40f294bf6254d2e1b66b8b6b400fc2e5">rt_pipe_alloc()</a>, <a class="el" href="group__pipe.html#ga8face1c57df99cf43b029b3e3b6a05c6">rt_pipe_free()</a>, and <a class="el" href="group__pipe.html#gaf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 10 2012 20:41:25 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
