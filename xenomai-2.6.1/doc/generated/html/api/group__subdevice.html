<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Subdevice management services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Subdevice management services<br/>
<small>
[<a class="el" href="group__driverfacilities.html">Driver API.</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Subdevice management services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__subdevice.png" border="0" alt="" usemap="#group____subdevice"/>
<map name="group____subdevice" id="group____subdevice">
<area shape="rect" id="node1" href="group__driverfacilities.html" title="Driver API." alt="" coords="5,5,93,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structa4l__subdevice.html">a4l_subdevice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing the subdevice.  <a href="structa4l__subdevice.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga32595b3806dd3e73038a2022c0b1e204">a4l_alloc_subd</a> (int sizeof_priv, void(*setup)(<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a subdevice descriptor.  <a href="#ga32595b3806dd3e73038a2022c0b1e204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga229e7725db234534da6e6973c63f1cef">a4l_add_subd</a> (a4l_dev_t *dev, <a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a subdevice to the driver descriptor.  <a href="#ga229e7725db234534da6e6973c63f1cef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gaa8b2dfadeac340e288725e1f2ce9b63b">a4l_get_subd</a> (a4l_dev_t *dev, int idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the subdevice descriptor referenced by its registration index.  <a href="#gaa8b2dfadeac340e288725e1f2ce9b63b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Subdevices types</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp2ebf2da86d6ab8804188bcae918624ba"></a>Flags to define the subdevice type</p>
<p><a class="anchor" id="ANALOGY_SUBD_xxx"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c70964ed18393fdeb7f6b985d7ae4f1"></a><!-- doxytag: member="subdevice::A4L_SUBD_UNUSED" ref="ga0c70964ed18393fdeb7f6b985d7ae4f1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga0c70964ed18393fdeb7f6b985d7ae4f1">A4L_SUBD_UNUSED</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unused subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe08fcb0bd2ac9015e058a1a38ebfade"></a><!-- doxytag: member="subdevice::A4L_SUBD_AI" ref="gafe08fcb0bd2ac9015e058a1a38ebfade" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gafe08fcb0bd2ac9015e058a1a38ebfade">A4L_SUBD_AI</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_READ|0x2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analog input subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5285a5093bd9279588a4b8fd05bb7c3f"></a><!-- doxytag: member="subdevice::A4L_SUBD_AO" ref="ga5285a5093bd9279588a4b8fd05bb7c3f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga5285a5093bd9279588a4b8fd05bb7c3f">A4L_SUBD_AO</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_WRITE|0x4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analog output subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4b6ee48948dc35895606488de102e14"></a><!-- doxytag: member="subdevice::A4L_SUBD_DI" ref="gad4b6ee48948dc35895606488de102e14" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gad4b6ee48948dc35895606488de102e14">A4L_SUBD_DI</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_READ|0x8)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Digital input subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf86e53e7a480bfb73df538dfd230efa2"></a><!-- doxytag: member="subdevice::A4L_SUBD_DO" ref="gaf86e53e7a480bfb73df538dfd230efa2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gaf86e53e7a480bfb73df538dfd230efa2">A4L_SUBD_DO</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_WRITE|0x10)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Digital output subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56fb70a0e2cf39e1be994d4b1e346162"></a><!-- doxytag: member="subdevice::A4L_SUBD_DIO" ref="ga56fb70a0e2cf39e1be994d4b1e346162" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga56fb70a0e2cf39e1be994d4b1e346162">A4L_SUBD_DIO</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x20)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Digital input/output subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9769a5004db6f3d45c1ac908fd1b9123"></a><!-- doxytag: member="subdevice::A4L_SUBD_COUNTER" ref="ga9769a5004db6f3d45c1ac908fd1b9123" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga9769a5004db6f3d45c1ac908fd1b9123">A4L_SUBD_COUNTER</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x40)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counter subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae4e41940b17d812ba852ac8739165262"></a><!-- doxytag: member="subdevice::A4L_SUBD_TIMER" ref="gae4e41940b17d812ba852ac8739165262" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gae4e41940b17d812ba852ac8739165262">A4L_SUBD_TIMER</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x80)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timer subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa38f1355eb6a7874ce5dcf8f90072d14"></a><!-- doxytag: member="subdevice::A4L_SUBD_MEMORY" ref="gaa38f1355eb6a7874ce5dcf8f90072d14" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gaa38f1355eb6a7874ce5dcf8f90072d14">A4L_SUBD_MEMORY</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x100)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory, EEPROM, DPRAM. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9eee756dede608de5263143191edec2"></a><!-- doxytag: member="subdevice::A4L_SUBD_CALIB" ref="gae9eee756dede608de5263143191edec2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gae9eee756dede608de5263143191edec2">A4L_SUBD_CALIB</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x200)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calibration subdevice DACs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf4d6837ce92a27aaf9b78d59fb6ba8e"></a><!-- doxytag: member="subdevice::A4L_SUBD_PROC" ref="gacf4d6837ce92a27aaf9b78d59fb6ba8e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gacf4d6837ce92a27aaf9b78d59fb6ba8e">A4L_SUBD_PROC</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x400)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processor, DSP. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga14c863f8e99d6be9a0d6371bcbe8fff1"></a><!-- doxytag: member="subdevice::A4L_SUBD_SERIAL" ref="ga14c863f8e99d6be9a0d6371bcbe8fff1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga14c863f8e99d6be9a0d6371bcbe8fff1">A4L_SUBD_SERIAL</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x800)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serial IO subdevice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffcb131508d9920aa4436c7df18a8ab1"></a><!-- doxytag: member="subdevice::A4L_SUBD_TYPES" ref="gaffcb131508d9920aa4436c7df18a8ab1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gaffcb131508d9920aa4436c7df18a8ab1">A4L_SUBD_TYPES</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask which gathers all the types. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Subdevice features</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp5b269635e10a7e161a60730ebd4f37f3"></a>Flags to define the subdevice's capabilities</p>
<p><a class="anchor" id="ANALOGY_SUBD_FT_xxx"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae57f549ab2689782e35af2c8941aeecf"></a><!-- doxytag: member="subdevice::A4L_SUBD_CMD" ref="gae57f549ab2689782e35af2c8941aeecf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gae57f549ab2689782e35af2c8941aeecf">A4L_SUBD_CMD</a>&nbsp;&nbsp;&nbsp;0x1000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice can handle command (i.e it can perform asynchronous acquisition). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ec26f0982c64fe7aab38678af7a20a4"></a><!-- doxytag: member="subdevice::A4L_SUBD_MMAP" ref="ga4ec26f0982c64fe7aab38678af7a20a4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga4ec26f0982c64fe7aab38678af7a20a4">A4L_SUBD_MMAP</a>&nbsp;&nbsp;&nbsp;0x8000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice support mmap operations (technically, any driver can do it; however, the developer might want that his driver must be accessed through read / write. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Subdevice status</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp5cf986c1fbfb188f4b548ef0f89dfdb5"></a>Flags to define the subdevice's status</p>
<p><a class="anchor" id="ANALOGY_SUBD_ST_xxx"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga943b015c909276644de277f4135e7579"></a><!-- doxytag: member="subdevice::A4L_SUBD_BUSY_NR" ref="ga943b015c909276644de277f4135e7579" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga943b015c909276644de277f4135e7579">A4L_SUBD_BUSY_NR</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice is busy, a synchronous or an asynchronous acquisition is occuring. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6114bf76458b8c6fd84813fa30f9338"></a><!-- doxytag: member="subdevice::A4L_SUBD_BUSY" ref="gaf6114bf76458b8c6fd84813fa30f9338" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gaf6114bf76458b8c6fd84813fa30f9338">A4L_SUBD_BUSY</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; A4L_SUBD_BUSY_NR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice is busy, a synchronous or an asynchronous acquisition is occuring. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6992c2972bde497a4039a21c5436dc75"></a><!-- doxytag: member="subdevice::A4L_SUBD_CLEAN_NR" ref="ga6992c2972bde497a4039a21c5436dc75" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga6992c2972bde497a4039a21c5436dc75">A4L_SUBD_CLEAN_NR</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice is about to be cleaned in the middle of the detach procedure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9cb84629a30d54bf81ea9daacc077238"></a><!-- doxytag: member="subdevice::A4L_SUBD_CLEAN" ref="ga9cb84629a30d54bf81ea9daacc077238" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga9cb84629a30d54bf81ea9daacc077238">A4L_SUBD_CLEAN</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; A4L_SUBD_CLEAN_NR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice is busy, a synchronous or an asynchronous acquisition is occuring. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Subdevice declaration in a driver</p>
<p>The subdevice structure is the most complex one in the Analogy driver layer. It contains some description fields to fill and some callbacks to declare.</p>
<p>The description fields are:</p>
<ul>
<li>flags: to define the subdevice type and its capabilities;</li>
<li>chan_desc: to describe the channels which compose the subdevice;</li>
<li>rng_desc: to declare the usable ranges;</li>
</ul>
<p>The functions callbakcs are:</p>
<ul>
<li>do_cmd() and do_cmdtest(): to performe asynchronous acquisitions thanks to commands;</li>
<li>cancel(): to abort a working asynchronous acquisition;</li>
<li>munge(): to apply modifications on the data freshly acquired during an asynchronous transfer. Warning: using this feature with can significantly reduce the performances (if the munge operation is complex, it will trigger high CPU charge and if the acquisition device is DMA capable, many cache-misses and cache-replaces will occur (the benefits of the DMA controller will vanish);</li>
<li>trigger(): optionnaly to launch an asynchronous acquisition;</li>
<li>insn_read(), insn_write(), insn_bits(), insn_config(): to perform synchronous acquisition operations.</li>
</ul>
<p>Once the subdevice is filled, it must be inserted into the driver structure thanks to <a class="el" href="group__subdevice.html#ga229e7725db234534da6e6973c63f1cef" title="Add a subdevice to the driver descriptor.">a4l_add_subd()</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga229e7725db234534da6e6973c63f1cef"></a><!-- doxytag: member="driver_facilities.c::a4l_add_subd" ref="ga229e7725db234534da6e6973c63f1cef" args="(a4l_dev_t *dev, a4l_subd_t *subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_add_subd </td>
          <td>(</td>
          <td class="paramtype">a4l_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a subdevice to the driver descriptor. </p>
<p>Once the driver descriptor structure is initialized, the function <a class="el" href="group__subdevice.html#ga229e7725db234534da6e6973c63f1cef" title="Add a subdevice to the driver descriptor.">a4l_add_subd()</a> must be used so to add some subdevices to the driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index with which the subdevice has been registered, in case of error a negative error code is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32595b3806dd3e73038a2022c0b1e204"></a><!-- doxytag: member="driver_facilities.c::a4l_alloc_subd" ref="ga32595b3806dd3e73038a2022c0b1e204" args="(int sizeof_priv, void(*setup)(a4l_subd_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a>* a4l_alloc_subd </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sizeof_priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *)&nbsp;</td>
          <td class="paramname"> <em>setup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a subdevice descriptor. </p>
<p>This is a helper function so as to get a suitable subdevice descriptor</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sizeof_priv</em>&nbsp;</td><td>Size of the subdevice's private data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>setup</em>&nbsp;</td><td>Setup function to be called after the allocation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index with which the subdevice has been registered, in case of error a negative error code is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8b2dfadeac340e288725e1f2ce9b63b"></a><!-- doxytag: member="driver_facilities.c::a4l_get_subd" ref="gaa8b2dfadeac340e288725e1f2ce9b63b" args="(a4l_dev_t *dev, int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a>* a4l_get_subd </td>
          <td>(</td>
          <td class="paramtype">a4l_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the subdevice descriptor referenced by its registration index. </p>
<p>This function is scarcely useful as all the drivers callbacks get the related subdevice descriptor as first argument. This function is not optimized, it goes through a linked list to get the proper pointer. So it must not be used in real-time context but at initialization / cleanup time (attach / detach).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>Subdevice index</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 10 2012 20:41:25 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
