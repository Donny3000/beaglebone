<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: rtcan_rtt.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>rtcan_rtt.c</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Round-Trip-Time Test - sends and receives messages and measures the</span>
<span class="comment"> *                        time in between.</span>
<span class="comment"> *</span>
<span class="comment"> * Copyright (C) 2006 Wolfgang Grandegger &lt;wg@grandegger.com&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * Based on RTnet&#39;s examples/xenomai/posix/rtt-sender.c.</span>
<span class="comment"> *</span>
<span class="comment"> * Copyright (C) 2002 Ulrich Marx &lt;marx@kammer.uni-hannover.de&gt;</span>
<span class="comment"> *               2002 Marc Kleine-Budde &lt;kleine-budde@gmx.de&gt;</span>
<span class="comment"> *               2006 Jan Kiszka &lt;jan.kiszka@web.de&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with this program; if not, write to the Free Software</span>
<span class="comment"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="comment"> *</span>
<span class="comment"> *</span>
<span class="comment"> * The program sends out CAN messages periodically and copies the current</span>
<span class="comment"> * time-stamp to the payload. At reception, that time-stamp is compared</span>
<span class="comment"> * with the current time to determine the round-trip time. The jitter</span>
<span class="comment"> * values are printer out regularly. Concurrent tests can be carried out</span>
<span class="comment"> * by starting the program with different message identifiers. It is also</span>
<span class="comment"> * possible to use this program on a remote system as simple repeater to</span>
<span class="comment"> * loopback messages.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;errno.h&gt;</span>
<span class="preprocessor">#include &lt;mqueue.h&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include &lt;pthread.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>
<span class="preprocessor">#include &lt;limits.h&gt;</span>
<span class="preprocessor">#include &lt;getopt.h&gt;</span>
<span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="preprocessor">#include &lt;net/if.h&gt;</span>
<span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
<span class="preprocessor">#include &lt;sys/mman.h&gt;</span>

<span class="preprocessor">#ifdef __XENO__</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="rtcan_8h.html" title="Real-Time Driver Model for RT-Socket-CAN, CAN device profile header.">rtdm/rtcan.h</a>&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/can.h&gt;</span>
<span class="preprocessor">#include &lt;linux/can/raw.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define NSEC_PER_SEC 1000000000</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 10000; <span class="comment">/* 10 ms */</span>
<span class="keyword">static</span> canid_t can_id = 0x1;

<span class="keyword">static</span> pthread_t txthread, rxthread;
<span class="keyword">static</span> <span class="keywordtype">int</span> txsock, rxsock;
<span class="keyword">static</span> mqd_t mq;
<span class="keyword">static</span> <span class="keywordtype">int</span> txcount, rxcount;
<span class="keyword">static</span> <span class="keywordtype">int</span> overruns;
<span class="keyword">static</span> <span class="keywordtype">int</span> repeater;

<span class="keyword">struct </span>rtt_stat {
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtt;
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtt_min;
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtt_max;
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtt_sum;
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtt_sum_last;
    <span class="keywordtype">int</span> counts_per_sec;
};

<span class="keyword">static</span> <span class="keywordtype">void</span> print_usage(<span class="keywordtype">char</span> *prg)
{
    fprintf(stderr,
            <span class="stringliteral">&quot;Usage: %s  [Options] &lt;tx-can-interface&gt; &lt;rx-can-interface&gt;\n&quot;</span>
            <span class="stringliteral">&quot;Options:\n&quot;</span>
            <span class="stringliteral">&quot; -h, --help     This help\n&quot;</span>
            <span class="stringliteral">&quot; -r, --repeater Repeater, send back received messages\n&quot;</span>
            <span class="stringliteral">&quot; -i, --id=ID    CAN Identifier (default = 0x1)\n&quot;</span>
            <span class="stringliteral">&quot; -c, --cycle    Cycle time in us (default = 10000us)\n&quot;</span>,
            prg);
}

<span class="keywordtype">void</span> *transmitter(<span class="keywordtype">void</span> *arg)
{
    <span class="keyword">struct </span>sched_param  param = { .sched_priority = 80 };
    <span class="keyword">struct </span>timespec next_period;
    <span class="keyword">struct </span>timespec time;
    <span class="keyword">struct </span><a name="_a0"></a><a class="code" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a> frame;
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> *rtt_time = (<span class="keywordtype">long</span> <span class="keywordtype">long</span> *)&amp;frame.data;

    <span class="comment">/* Pre-fill CAN frame */</span>
    frame.can_id = <a name="a1"></a><a class="code" href="structcan__frame.html#a0294f06f81a3ae0d155eb5fd14733d63" title="CAN ID of the frame.">can_id</a>;
    frame.can_dlc = <span class="keyword">sizeof</span>(*rtt_time);

<span class="preprocessor">#ifdef __XENO__</span>
<span class="preprocessor"></span>    <a name="a2"></a><a class="code" href="group__posix__thread.html#ga414a759c928f7be7ac105980d8e73431" title="Set a thread name.">pthread_set_name_np</a>(<a name="a3"></a><a class="code" href="group__posix__thread.html#ga4c4f5f3b4f8f45d9d897847d53b11aaa" title="Get the identifier of the calling thread.">pthread_self</a>(), <span class="stringliteral">&quot;rtcan_rtt_transmitter&quot;</span>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <a name="a4"></a><a class="code" href="group__posix__sched.html#ga95276f88e1a2cae7a37f792123a99144" title="Set the scheduling policy and parameters of the specified thread.">pthread_setschedparam</a>(<a class="code" href="group__posix__thread.html#ga4c4f5f3b4f8f45d9d897847d53b11aaa" title="Get the identifier of the calling thread.">pthread_self</a>(), SCHED_FIFO, &amp;param);

    <a name="a5"></a><a class="code" href="group__posix__time.html#ga10b73e75d375e5c244e32ea46be775bf" title="Read the specified clock.">clock_gettime</a>(CLOCK_MONOTONIC, &amp;next_period);

    <span class="keywordflow">while</span>(1) {
        next_period.tv_nsec += cycle * 1000;
        <span class="keywordflow">while</span> (next_period.tv_nsec &gt;= NSEC_PER_SEC) {
                next_period.tv_nsec -= NSEC_PER_SEC;
                next_period.tv_sec++;
        }

        <a name="a6"></a><a class="code" href="group__posix__time.html#ga924d51d78cdcd9d7dee2613fb3a33cd1" title="Sleep some amount of time.">clock_nanosleep</a>(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;next_period, NULL);

        <span class="keywordflow">if</span> (rxcount != txcount) {
            overruns++;
            <span class="keywordflow">continue</span>;
        }

        <a class="code" href="group__posix__time.html#ga10b73e75d375e5c244e32ea46be775bf" title="Read the specified clock.">clock_gettime</a>(CLOCK_MONOTONIC, &amp;time);
        *rtt_time = (<span class="keywordtype">long</span> long)time.tv_sec * NSEC_PER_SEC + time.tv_nsec;

        <span class="comment">/* Transmit the message containing the local time */</span>
        if (send(txsock, (<span class="keywordtype">void</span> *)&amp;frame, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>), 0) &lt; 0) {
            <span class="keywordflow">if</span> (errno == EBADF)
                printf(<span class="stringliteral">&quot;terminating transmitter thread\n&quot;</span>);
            <span class="keywordflow">else</span>
                perror(<span class="stringliteral">&quot;send failed&quot;</span>);
            <span class="keywordflow">return</span> NULL;
        }
        txcount++;
    }
}


<span class="keywordtype">void</span> *receiver(<span class="keywordtype">void</span> *arg)
{
    <span class="keyword">struct </span>sched_param param = { .sched_priority = 82 };
    <span class="keyword">struct </span>timespec time;
    <span class="keyword">struct </span><a class="code" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a> frame;
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> *rtt_time = (<span class="keywordtype">long</span> <span class="keywordtype">long</span> *)frame.data;
    <span class="keyword">struct</span> rtt_stat rtt_stat = {0, 1000000000000000000LL, -1000000000000000000LL,
                                0, 0, 0};

<span class="preprocessor">#ifdef __XENO__</span>
<span class="preprocessor"></span>    <a class="code" href="group__posix__thread.html#ga414a759c928f7be7ac105980d8e73431" title="Set a thread name.">pthread_set_name_np</a>(<a class="code" href="group__posix__thread.html#ga4c4f5f3b4f8f45d9d897847d53b11aaa" title="Get the identifier of the calling thread.">pthread_self</a>(), <span class="stringliteral">&quot;rtcan_rtt_receiver&quot;</span>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <a class="code" href="group__posix__sched.html#ga95276f88e1a2cae7a37f792123a99144" title="Set the scheduling policy and parameters of the specified thread.">pthread_setschedparam</a>(<a class="code" href="group__posix__thread.html#ga4c4f5f3b4f8f45d9d897847d53b11aaa" title="Get the identifier of the calling thread.">pthread_self</a>(), SCHED_FIFO, &amp;param);

    rtt_stat.counts_per_sec = 1000000 / cycle;

    <span class="keywordflow">while</span> (1) {
        <span class="keywordflow">if</span> (recv(rxsock, (<span class="keywordtype">void</span> *)&amp;frame, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>), 0) &lt; 0) {
            <span class="keywordflow">if</span> (errno == EBADF)
                printf(<span class="stringliteral">&quot;terminating receiver thread\n&quot;</span>);
            <span class="keywordflow">else</span>
                perror(<span class="stringliteral">&quot;recv failed&quot;</span>);
            <span class="keywordflow">return</span> NULL;
        }
        <span class="keywordflow">if</span> (repeater) {
            <span class="comment">/* Transmit the message back as is */</span>
            <span class="keywordflow">if</span> (send(txsock, (<span class="keywordtype">void</span> *)&amp;frame, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>), 0) &lt; 0) {
                <span class="keywordflow">if</span> (errno == EBADF)
                    printf(<span class="stringliteral">&quot;terminating transmitter thread\n&quot;</span>);
                <span class="keywordflow">else</span>
                    perror(<span class="stringliteral">&quot;send failed&quot;</span>);
                <span class="keywordflow">return</span> NULL;
            }
            txcount++;
        } <span class="keywordflow">else</span> {
            <a class="code" href="group__posix__time.html#ga10b73e75d375e5c244e32ea46be775bf" title="Read the specified clock.">clock_gettime</a>(CLOCK_MONOTONIC, &amp;time);
            <span class="keywordflow">if</span> (rxcount &gt; 0) {
                rtt_stat.rtt = ((<span class="keywordtype">long</span> long)time.tv_sec * 1000000000LL +
                                time.tv_nsec - *rtt_time);
                rtt_stat.rtt_sum += rtt_stat.rtt;
                <span class="keywordflow">if</span> (rtt_stat.rtt &lt;  rtt_stat.rtt_min)
                    rtt_stat.rtt_min = rtt_stat.rtt;
                <span class="keywordflow">if</span> (rtt_stat.rtt &gt; rtt_stat.rtt_max)
                    rtt_stat.rtt_max = rtt_stat.rtt;
            }
        }
        rxcount++;

        <span class="keywordflow">if</span> ((rxcount % rtt_stat.counts_per_sec) == 0) {
            <a name="a7"></a><a class="code" href="group__posix__mq.html#gae3d8e022fcc1114c0cd4b30ccd1f15e4" title="Send a message to a message queue.">mq_send</a>(mq, (<span class="keywordtype">char</span> *)&amp;rtt_stat, <span class="keyword">sizeof</span>(rtt_stat), 0);
            rtt_stat.rtt_sum_last = rtt_stat.rtt_sum;
        }
    }
}

<span class="keywordtype">void</span> catch_signal(<span class="keywordtype">int</span> sig)
{
    <a name="a8"></a><a class="code" href="group__posix__mq.html#ga14a1dc0204a7f84bb4e8a1813a70af49" title="Close a message queue.">mq_close</a>(mq);
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keyword">struct </span>sched_param param = { .sched_priority = 1 };
    pthread_attr_t thattr;
    <span class="keyword">struct </span>mq_attr mqattr;
    <span class="keyword">struct </span><a name="_a9"></a><a class="code" href="structsockaddr__can.html" title="Socket address structure for the CAN address family.">sockaddr_can</a> rxaddr, txaddr;
    <span class="keyword">struct </span><a name="_a10"></a><a class="code" href="structcan__filter.html" title="Filter for reception of CAN messages.">can_filter</a> rxfilter[1];
    <span class="keyword">struct </span>rtt_stat rtt_stat;
    <span class="keywordtype">char</span> mqname[32];
    <span class="keywordtype">char</span> *txdev, *rxdev;
    <span class="keyword">struct </span>ifreq ifr;
    <span class="keywordtype">int</span> ret, opt;

    <span class="keyword">struct </span>option long_options[] = {
        { <span class="stringliteral">&quot;id&quot;</span>, required_argument, 0, <span class="charliteral">&#39;i&#39;</span>},
        { <span class="stringliteral">&quot;cycle&quot;</span>, required_argument, 0, <span class="charliteral">&#39;c&#39;</span>},
        { <span class="stringliteral">&quot;repeater&quot;</span>, no_argument, 0, <span class="charliteral">&#39;r&#39;</span>},
        { <span class="stringliteral">&quot;help&quot;</span>, no_argument, 0, <span class="charliteral">&#39;h&#39;</span>},
        { 0, 0, 0, 0},
    };

    <span class="keywordflow">while</span> ((opt = getopt_long(argc, argv, <span class="stringliteral">&quot;hri:c:&quot;</span>,
                              long_options, NULL)) != -1) {
        <span class="keywordflow">switch</span> (opt) {
        <span class="keywordflow">case</span> <span class="charliteral">&#39;c&#39;</span>:
            cycle = atoi(optarg);
            <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> <span class="charliteral">&#39;i&#39;</span>:
            can_id = strtoul(optarg, NULL, 0);
            <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> <span class="charliteral">&#39;r&#39;</span>:
            repeater = 1;
            <span class="keywordflow">break</span>;

        <span class="keywordflow">default</span>:
            fprintf(stderr, <span class="stringliteral">&quot;Unknown option %c\n&quot;</span>, opt);
        <span class="keywordflow">case</span> <span class="charliteral">&#39;h&#39;</span>:
            print_usage(argv[0]);
            exit(-1);
        }
    }

    printf(<span class="stringliteral">&quot;%d %d\n&quot;</span>, optind, argc);
    <span class="keywordflow">if</span> (optind + 2 != argc) {
        print_usage(argv[0]);
        exit(0);
    }

    txdev = argv[optind];
    rxdev = argv[optind + 1];

    <span class="comment">/* Create and configure RX socket */</span>
    <span class="keywordflow">if</span> ((rxsock = socket(<a name="a11"></a><a class="code" href="group__rtcan.html#gaeac0c3db7a1e021f17987bcc76893849" title="CAN protocol family.">PF_CAN</a>, SOCK_RAW, <a name="a12"></a><a class="code" href="group__rtcan.html#ga57682d9a1e4f4d90943dbaa683582bf5" title="Raw protocol of PF_CAN, applicable to socket type SOCK_RAW.">CAN_RAW</a>)) &lt; 0) {
        perror(<span class="stringliteral">&quot;RX socket failed&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    strncpy(ifr.ifr_name, rxdev, IFNAMSIZ);
    printf(<span class="stringliteral">&quot;RX rxsock=%d, ifr_name=%s\n&quot;</span>, rxsock, ifr.ifr_name);

    <span class="keywordflow">if</span> (ioctl(rxsock, <a name="a13"></a><a class="code" href="group__rtcan.html#gaee74ae50c8ea0a6aee277c6f124a3866" title="Get CAN interface index by name.">SIOCGIFINDEX</a>, &amp;ifr) &lt; 0) {
        perror(<span class="stringliteral">&quot;RX ioctl SIOCGIFINDEX failed&quot;</span>);
        <span class="keywordflow">goto</span> failure1;
    }

    <span class="comment">/* We only want to receive our own messages */</span>
    rxfilter[0].can_id = can_id;
    rxfilter[0].can_mask = 0x3ff;
    <span class="keywordflow">if</span> (setsockopt(rxsock, <a name="a14"></a><a class="code" href="group__rtcan.html#gad981aa82a29d828882a2fb4c35c1cdd7" title="CAN socket levels.">SOL_CAN_RAW</a>, <a name="a15"></a><a class="code" href="group__rtcan.html#ga87313c6e632294aa4582899a3bbc89e4" title="CAN filter definition.">CAN_RAW_FILTER</a>,
                   &amp;rxfilter, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcan__filter.html" title="Filter for reception of CAN messages.">can_filter</a>)) &lt; 0) {
        perror(<span class="stringliteral">&quot;RX setsockopt CAN_RAW_FILTER failed&quot;</span>);
        <span class="keywordflow">goto</span> failure1;
    }
    memset(&amp;rxaddr, 0, <span class="keyword">sizeof</span>(rxaddr));
    rxaddr.can_ifindex = ifr.ifr_ifindex;
    rxaddr.can_family = AF_CAN;
    <span class="keywordflow">if</span> (bind(rxsock, (<span class="keyword">struct</span> sockaddr *)&amp;rxaddr, <span class="keyword">sizeof</span>(rxaddr)) &lt; 0) {
        perror(<span class="stringliteral">&quot;RX bind failed\n&quot;</span>);
        <span class="keywordflow">goto</span> failure1;
    }

    <span class="comment">/* Create and configure TX socket */</span>

    <span class="keywordflow">if</span> (strcmp(rxdev, txdev) == 0) {
        txsock = rxsock;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">if</span> ((txsock = socket(<a class="code" href="group__rtcan.html#gaeac0c3db7a1e021f17987bcc76893849" title="CAN protocol family.">PF_CAN</a>, SOCK_RAW, 0)) &lt; 0) {
            perror(<span class="stringliteral">&quot;TX socket failed&quot;</span>);
            <span class="keywordflow">goto</span> failure1;
        }

        strncpy(ifr.ifr_name, txdev, IFNAMSIZ);
        printf(<span class="stringliteral">&quot;TX txsock=%d, ifr_name=%s\n&quot;</span>, txsock, ifr.ifr_name);

        <span class="keywordflow">if</span> (ioctl(txsock, <a class="code" href="group__rtcan.html#gaee74ae50c8ea0a6aee277c6f124a3866" title="Get CAN interface index by name.">SIOCGIFINDEX</a>, &amp;ifr) &lt; 0) {
            perror(<span class="stringliteral">&quot;TX ioctl SIOCGIFINDEX failed&quot;</span>);
            <span class="keywordflow">goto</span> failure2;
        }

        <span class="comment">/* Suppress definiton of a default receive filter list */</span>
        <span class="keywordflow">if</span> (setsockopt(txsock, <a class="code" href="group__rtcan.html#gad981aa82a29d828882a2fb4c35c1cdd7" title="CAN socket levels.">SOL_CAN_RAW</a>, <a class="code" href="group__rtcan.html#ga87313c6e632294aa4582899a3bbc89e4" title="CAN filter definition.">CAN_RAW_FILTER</a>, NULL, 0) &lt; 0) {
            perror(<span class="stringliteral">&quot;TX setsockopt CAN_RAW_FILTER failed&quot;</span>);
            <span class="keywordflow">goto</span> failure2;
        }

        memset(&amp;txaddr, 0, <span class="keyword">sizeof</span>(txaddr));
        txaddr.can_ifindex = ifr.ifr_ifindex;
        txaddr.can_family = AF_CAN;

        <span class="keywordflow">if</span> (bind(txsock, (<span class="keyword">struct</span> sockaddr *)&amp;txaddr, <span class="keyword">sizeof</span>(txaddr)) &lt; 0) {
                perror(<span class="stringliteral">&quot;TX bind failed\n&quot;</span>);
                <span class="keywordflow">goto</span> failure2;
        }
    }

    signal(SIGTERM, catch_signal);
    signal(SIGINT, catch_signal);
    signal(SIGHUP, catch_signal);
    mlockall(MCL_CURRENT|MCL_FUTURE);

    printf(<span class="stringliteral">&quot;Round-Trip-Time test %s -&gt; %s with CAN ID 0x%x\n&quot;</span>,
           argv[optind], argv[optind + 1], can_id);
    printf(<span class="stringliteral">&quot;Cycle time: %d us\n&quot;</span>, cycle);
    printf(<span class="stringliteral">&quot;All RTT timing figures are in us.\n&quot;</span>);

    <span class="comment">/* Create statistics message queue */</span>
    snprintf(mqname, <span class="keyword">sizeof</span>(mqname), <span class="stringliteral">&quot;/rtcan_rtt-%d&quot;</span>, getpid());
    mqattr.mq_flags   = 0;
    mqattr.mq_maxmsg  = 100;
    mqattr.mq_msgsize = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>rtt_stat);
    mq = <a name="a16"></a><a class="code" href="group__posix__mq.html#ga6e6c4881ac0fd3ad18d733b96d088b8b" title="Open a message queue.">mq_open</a>(mqname, O_RDWR | O_CREAT | O_EXCL, 0600, &amp;mqattr);
    <span class="keywordflow">if</span> (mq == (mqd_t)-1) {
        perror(<span class="stringliteral">&quot;opening mqueue failed&quot;</span>);
        <span class="keywordflow">goto</span> failure2;
    }

    <span class="comment">/* Create receiver RT-thread */</span>
    <a name="a17"></a><a class="code" href="group__posix__threadattr.html#ga0b85ebb1e3aac081a4c0a5e85ae3cbe9" title="Initialize a thread attributes object.">pthread_attr_init</a>(&amp;thattr);
    <a name="a18"></a><a class="code" href="group__posix__threadattr.html#gae6ee78c307d8467b34a9b0c330993a54" title="Set detachstate attribute.">pthread_attr_setdetachstate</a>(&amp;thattr, PTHREAD_CREATE_JOINABLE);
    <a name="a19"></a><a class="code" href="group__posix__threadattr.html#ga812a9a455ae2ef2bb0dca4fff201a281" title="Set stacksize attribute.">pthread_attr_setstacksize</a>(&amp;thattr, PTHREAD_STACK_MIN);
    ret = <a name="a20"></a><a class="code" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c" title="Create a thread.">pthread_create</a>(&amp;rxthread, &amp;thattr, &amp;receiver, NULL);
    <span class="keywordflow">if</span> (ret) {
        fprintf(stderr, <span class="stringliteral">&quot;%s: pthread_create(receiver) failed\n&quot;</span>,
                strerror(-ret));
        <span class="keywordflow">goto</span> failure3;
    }

    <span class="keywordflow">if</span> (!repeater) {
        <span class="comment">/* Create transitter RT-thread */</span>
        ret = <a class="code" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c" title="Create a thread.">pthread_create</a>(&amp;txthread, &amp;thattr, &amp;transmitter, NULL);
        <span class="keywordflow">if</span> (ret) {
            fprintf(stderr, <span class="stringliteral">&quot;%s: pthread_create(transmitter) failed\n&quot;</span>,
                    strerror(-ret));
            <span class="keywordflow">goto</span> failure4;
        }
    }

    <a class="code" href="group__posix__sched.html#ga95276f88e1a2cae7a37f792123a99144" title="Set the scheduling policy and parameters of the specified thread.">pthread_setschedparam</a>(<a class="code" href="group__posix__thread.html#ga4c4f5f3b4f8f45d9d897847d53b11aaa" title="Get the identifier of the calling thread.">pthread_self</a>(), SCHED_FIFO, &amp;param);

    <span class="keywordflow">if</span> (repeater)
        printf(<span class="stringliteral">&quot;Messages\n&quot;</span>);
    <span class="keywordflow">else</span>
        printf(<span class="stringliteral">&quot;Messages RTTlast RTT_avg RTT_min RTT_max Overruns\n&quot;</span>);

    <span class="keywordflow">while</span> (1) {
        <span class="keywordtype">long</span> <span class="keywordtype">long</span> rtt_avg;

        ret = <a name="a21"></a><a class="code" href="group__posix__mq.html#ga6370a6bb8f2b87e52ec4fcf340939128" title="Receive a message from a message queue.">mq_receive</a>(mq, (<span class="keywordtype">char</span> *)&amp;rtt_stat, <span class="keyword">sizeof</span>(rtt_stat), NULL);
        <span class="keywordflow">if</span> (ret != <span class="keyword">sizeof</span>(rtt_stat)) {
            <span class="keywordflow">if</span> (ret &lt; 0) {
                <span class="keywordflow">if</span> (errno == EBADF)
                    printf(<span class="stringliteral">&quot;terminating mq_receive\n&quot;</span>);
                <span class="keywordflow">else</span>
                    perror(<span class="stringliteral">&quot;mq_receive failed&quot;</span>);
            } <span class="keywordflow">else</span>
                fprintf(stderr,
                        <span class="stringliteral">&quot;mq_receive returned invalid length %d\n&quot;</span>, ret);
            <span class="keywordflow">break</span>;
        }

        <span class="keywordflow">if</span> (repeater) {
            printf(<span class="stringliteral">&quot;%8d\n&quot;</span>, rxcount);
        } <span class="keywordflow">else</span> {
            rtt_avg = ((rtt_stat.rtt_sum - rtt_stat.rtt_sum_last) /
                       rtt_stat.counts_per_sec);
            printf(<span class="stringliteral">&quot;%8d %7ld %7ld %7ld %7ld %8d\n&quot;</span>, rxcount,
                   (<span class="keywordtype">long</span>)(rtt_stat.rtt / 1000), (<span class="keywordtype">long</span>)(rtt_avg / 1000),
                   (<span class="keywordtype">long</span>)(rtt_stat.rtt_min / 1000),
                   (<span class="keywordtype">long</span>)(rtt_stat.rtt_max / 1000),
                   overruns);
        }
    }

    <span class="comment">/* This call also leaves primary mode, required for socket cleanup. */</span>
    printf(<span class="stringliteral">&quot;shutting down\n&quot;</span>);

    <span class="comment">/* Important: First close the sockets! */</span>
    <span class="keywordflow">while</span> ((<a name="a22"></a><a class="code" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close</a>(rxsock) &lt; 0) &amp;&amp; (errno == EAGAIN)) {
        printf(<span class="stringliteral">&quot;RX socket busy - waiting...\n&quot;</span>);
        sleep(1);
    }
    <span class="keywordflow">while</span> ((<a class="code" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close</a>(txsock) &lt; 0) &amp;&amp; (errno == EAGAIN)) {
        printf(<span class="stringliteral">&quot;TX socket busy - waiting...\n&quot;</span>);
        sleep(1);
    }

    <a name="a23"></a><a class="code" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join</a>(txthread, NULL);
    <a name="a24"></a><a class="code" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62" title="Send a signal to a thread.">pthread_kill</a>(rxthread, SIGHUP);
    <a class="code" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join</a>(rxthread, NULL);

    <span class="keywordflow">return</span> 0;

 failure4:
    <a class="code" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62" title="Send a signal to a thread.">pthread_kill</a>(rxthread, SIGHUP);
    <a class="code" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join</a>(rxthread, NULL);
 failure3:
    <a class="code" href="group__posix__mq.html#ga14a1dc0204a7f84bb4e8a1813a70af49" title="Close a message queue.">mq_close</a>(mq);
 failure2:
    <a class="code" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close</a>(txsock);
 failure1:
    <a class="code" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close</a>(rxsock);

    <span class="keywordflow">return</span> 1;
}
</pre></div> </div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 10 2012 20:41:21 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
