<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Timer services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Timer services.<br/>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Timer services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__timer.png" border="0" alt="" usemap="#group____timer"/>
<map name="group____timer" id="group____timer">
<area shape="rect" id="node1" href="group__nucleus.html" title="Xenomai nucleus." alt="" coords="7,5,143,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="include_2nucleus_2timer_8h.html">timer.h</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2nucleus_2timer_8c.html">timer.c</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab">xntimer_start</a> (xntimer_t *timer, xnticks_t value, xnticks_t interval, xntmode_t mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arm a timer.  <a href="#ga0ad3c70bed7fe1a45b45ee0875f031ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga1244411df9784d63d3e2f99016d62643">xntimer_stop</a> (xntimer_t *timer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disarm a timer.  <a href="#ga1244411df9784d63d3e2f99016d62643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#gae87b875cf9f6831afffcfee8dabd67a8">xntimer_get_date</a> (xntimer_t *timer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the absolute expiration date.  <a href="#gae87b875cf9f6831afffcfee8dabd67a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga00d603a038b09e436717b84975b00abf">xntimer_get_timeout</a> (xntimer_t *timer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the relative expiration date.  <a href="#ga00d603a038b09e436717b84975b00abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#gab0d00a02bf04fdd48987d5d4efa68190">xntimer_get_interval</a> (xntimer_t *timer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the timer interval value.  <a href="#gab0d00a02bf04fdd48987d5d4efa68190"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga26727f15ac845719913dcb703bf0c3fa">xntimer_tick_aperiodic</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a timer tick for the aperiodic master time base.  <a href="#ga26727f15ac845719913dcb703bf0c3fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga9b5391e752a8e16d89fb6a99c76bb7b1">xntimer_tick_periodic</a> (xntimer_t *mtimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a timer tick for a slave periodic time base.  <a href="#ga9b5391e752a8e16d89fb6a99c76bb7b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga834e46fb4c1ecaab949eea77b9dee284">xntimer_init</a> (xntimer_t *timer, xntbase_t *base, void(*handler)(xntimer_t *timer))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a timer object.  <a href="#ga834e46fb4c1ecaab949eea77b9dee284"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga782e10b2cd24a5c303b316375940ca15">xntimer_destroy</a> (xntimer_t *timer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a timer object.  <a href="#ga782e10b2cd24a5c303b316375940ca15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga5609dd2602efe2c5b04eda28b22b9720">xntimer_get_overruns</a> (xntimer_t *timer, xnticks_t now)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the count of overruns for the last tick.  <a href="#ga5609dd2602efe2c5b04eda28b22b9720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timer.html#ga5cad677279089ef19d3710b1b6452a71">xntimer_freeze</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Freeze all timers (from every time bases).  <a href="#ga5cad677279089ef19d3710b1b6452a71"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The Xenomai timer facility always operate the timer hardware in oneshot mode, regardless of the time base in effect. Periodic timing is obtained through a software emulation, using cascading timers.</p>
<p>Depending on the time base used, the timer object stores time values either as count of jiffies (periodic), or as count of CPU ticks (aperiodic). </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga782e10b2cd24a5c303b316375940ca15"></a><!-- doxytag: member="timer.c::xntimer_destroy" ref="ga782e10b2cd24a5c303b316375940ca15" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_destroy </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release a timer object. </p>
<p>Destroys a timer. After it has been destroyed, all resources associated with the timer have been released. The timer is automatically deactivated before deletion if active on entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__timer.html#ga1244411df9784d63d3e2f99016d62643">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__alarm.html#gaf00e05b47b1183816480e270d326f9ac">rt_alarm_delete()</a>, <a class="el" href="group__rtdmtimer.html#gac75c6e2f7c838b11d8e261be3a7a0326">rtdm_timer_destroy()</a>, <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>, and <a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84">xnpod_shutdown()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5cad677279089ef19d3710b1b6452a71"></a><!-- doxytag: member="timer.c::xntimer_freeze" ref="ga5cad677279089ef19d3710b1b6452a71" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_freeze </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Freeze all timers (from every time bases). </p>
<p><b>For internal use only.</b></p>
<p>This routine deactivates all active timers atomically.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__pod.html#ga179f47d6e98446843f059790112dcce3">xnpod_disable_timesource()</a>.</p>

</div>
</div>
<a class="anchor" id="gae87b875cf9f6831afffcfee8dabd67a8"></a><!-- doxytag: member="timer.h::xntimer_get_date" ref="gae87b875cf9f6831afffcfee8dabd67a8" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_date </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the absolute expiration date. </p>
<p>Return the next expiration date of a timer in absolute clock ticks (see note).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

<p>Referenced by <a class="el" href="group__task.html#ga53bad6acf5496f8008e594954507dce8">rt_task_inquire()</a>.</p>

</div>
</div>
<a class="anchor" id="gab0d00a02bf04fdd48987d5d4efa68190"></a><!-- doxytag: member="timer.h::xntimer_get_interval" ref="gab0d00a02bf04fdd48987d5d4efa68190" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_interval </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the timer interval value. </p>
<p>Return the timer interval value in clock ticks (see note).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive or aperiodic.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5609dd2602efe2c5b04eda28b22b9720"></a><!-- doxytag: member="timer.c::xntimer_get_overruns" ref="ga5609dd2602efe2c5b04eda28b22b9720" args="(xntimer_t *timer, xnticks_t now)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long xntimer_get_overruns </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>now</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the count of overruns for the last tick. </p>
<p>This service returns the count of pending overruns for the last tick of a given timer, as measured by the difference between the expected expiry date of the timer and the date <em>now</em> passed as argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>now</em>&nbsp;</td><td>current date (in the monotonic time base)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of overruns of <em>timer</em> at date <em>now</em> </dd></dl>

<p>Referenced by <a class="el" href="group__pod.html#gaf836996e4a3378928f2a9f93a4915cfa">xnpod_wait_thread_period()</a>.</p>

</div>
</div>
<a class="anchor" id="ga00d603a038b09e436717b84975b00abf"></a><!-- doxytag: member="timer.h::xntimer_get_timeout" ref="ga00d603a038b09e436717b84975b00abf" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_timeout </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the relative expiration date. </p>
<p>Return the next expiration date of a timer in relative clock ticks (see note).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The expiration date converted to the current time unit. The special value XN_INFINITE is returned if <em>timer</em> is currently inactive. In oneshot mode, it might happen that the timer has already expired when this service is run (even if the associated handler has not been fired yet); in such a case, 1 is returned.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

<p>Referenced by <a class="el" href="group__alarm.html#ga25c4556b6e2f6fa220a734bf83c4c374">rt_alarm_inquire()</a>.</p>

</div>
</div>
<a class="anchor" id="ga834e46fb4c1ecaab949eea77b9dee284"></a><!-- doxytag: member="timer.c::xntimer_init" ref="ga834e46fb4c1ecaab949eea77b9dee284" args="(xntimer_t *timer, xntbase_t *base, void(*handler)(xntimer_t *timer))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_init </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntbase_t *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(xntimer_t *timer)&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a timer object. </p>
<p>Creates a timer. When created, a timer is left disarmed; it must be started using <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab" title="Arm a timer.">xntimer_start()</a> in order to be activated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a timer descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>The descriptor address of the time base the new timer depends on. See <a class="el" href="group__timebase.html#gafcb0a76ac26eaaa768db89cb54e3f24a" title="Allocate a time base.">xntbase_alloc()</a> for detailed explanations about time bases.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The routine to call upon expiration of the timer.</td></tr>
  </table>
  </dd>
</dl>
<p>There is no limitation on the number of timers which can be created/active concurrently.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__alarm.html#ga22353f79379121bbebfa0e72bbde5028">rt_alarm_create()</a>, <a class="el" href="group__posix__time.html#ga8a24ab6b0901162bbbbbca4f5205abd0">timer_create()</a>, and <a class="el" href="group__pod.html#ga167bb3b4251ac8b8a3e7f358d236908a">xnpod_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ad3c70bed7fe1a45b45ee0875f031ab"></a><!-- doxytag: member="timer.h::xntimer_start" ref="ga0ad3c70bed7fe1a45b45ee0875f031ab" args="(xntimer_t *timer, xnticks_t value, xnticks_t interval, xntmode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_start </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arm a timer. </p>
<p>Activates a timer so that the associated timeout handler will be fired after each expiration time. A timer can be either periodic or single-shot, depending on the reload value passed to this routine. The given timer must have been previously initialized, and will be clocked according to the policy defined by the time base specified in <a class="el" href="group__timer.html#ga834e46fb4c1ecaab949eea77b9dee284" title="Initialize a timer object.">xntimer_init()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The date of the initial timer shot, expressed in clock ticks (see note).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The reload value of the timer. It is a periodic interval value to be used for reprogramming the next timer shot, expressed in clock ticks (see note). If <em>interval</em> is equal to XN_INFINITE, the timer will not be reloaded after it has expired.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The timer mode. It can be XN_RELATIVE if <em>value</em> shall be interpreted as a relative date, XN_ABSOLUTE for an absolute date based on the monotonic clock of the related time base (as returned my xntbase_get_jiffies()), or XN_REALTIME if the absolute date is based on the adjustable real-time clock of the time base (as returned by <a class="el" href="group__timebase.html#ga5246b53b5b2d1b11d4fab4312fd16fda" title="Get the clock time for a given time base.">xntbase_get_time()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -ETIMEDOUT if an absolute date in the past has been given.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the associated time base, as defined by the xnpod_init_timebase() service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds.</dd>
<dd>
Must be called with nklock held, IRQs off. </dd></dl>

<p>Referenced by <a class="el" href="group__alarm.html#ga0d9cb8ae623be0f7224ac47b10a0b542">rt_alarm_start()</a>, <a class="el" href="group__rtdmtimer.html#ga429ca4935762583edb6e1ebc955fe958">rtdm_timer_start()</a>, <a class="el" href="group__posix__time.html#ga2b1ff7e69f27d7aec7950b42494fa61f">timer_settime()</a>, <a class="el" href="group__pod.html#ga10d3c13efa3ab06ac23017710b13314e">xnpod_enable_timesource()</a>, <a class="el" href="group__pod.html#gaed5776a428e7c59b52b1da76f0d765fa">xnpod_set_thread_periodic()</a>, <a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice()</a>, and <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1244411df9784d63d3e2f99016d62643"></a><!-- doxytag: member="timer.h::xntimer_stop" ref="ga1244411df9784d63d3e2f99016d62643" args="(xntimer_t *timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xntimer_stop </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>timer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disarm a timer. </p>
<p>This service deactivates a timer previously armed using <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab" title="Arm a timer.">xntimer_start()</a>. Once disarmed, the timer can be subsequently re-armed using the latter service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Must be called with nklock held, IRQs off. </dd></dl>

<p>Referenced by <a class="el" href="group__alarm.html#ga71f2ffec98e3e23fe5d7f87c2cb24d77">rt_alarm_stop()</a>, <a class="el" href="group__rtdmtimer.html#ga7f2accf693db9ed5a537b86a58bccd94">rtdm_timer_stop()</a>, <a class="el" href="group__posix__time.html#ga2b1ff7e69f27d7aec7950b42494fa61f">timer_settime()</a>, <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>, <a class="el" href="group__pod.html#gaed5776a428e7c59b52b1da76f0d765fa">xnpod_set_thread_periodic()</a>, <a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice()</a>, and <a class="el" href="group__timer.html#ga782e10b2cd24a5c303b316375940ca15">xntimer_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga26727f15ac845719913dcb703bf0c3fa"></a><!-- doxytag: member="timer.c::xntimer_tick_aperiodic" ref="ga26727f15ac845719913dcb703bf0c3fa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_tick_aperiodic </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a timer tick for the aperiodic master time base. </p>
<p><b>For internal use only.</b></p>
<p>This routine informs all active timers that the clock has been updated by processing the outstanding timer list. Elapsed timer actions will be fired.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Interrupt service routine, nklock locked, interrupts off</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structxnsched.html#ae2818d36a93ef25f121c67f2ff34d236">xnsched::htimer</a>, <a class="el" href="structxnsched.html#a4e9ca82832cb0709308e7d78e7f9d694">xnsched::lflags</a>, and <a class="el" href="structxnsched.html#ad700d0003b158a60599221047b2fc52e">xnsched::status</a>.</p>

<p>Referenced by <a class="el" href="group__timebase.html#ga15896b6c498acdc5e2516ad0cc9df5ac">xntbase_tick()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b5391e752a8e16d89fb6a99c76bb7b1"></a><!-- doxytag: member="timer.c::xntimer_tick_periodic" ref="ga9b5391e752a8e16d89fb6a99c76bb7b1" args="(xntimer_t *mtimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_tick_periodic </td>
          <td>(</td>
          <td class="paramtype">xntimer_t *&nbsp;</td>
          <td class="paramname"> <em>mtimer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a timer tick for a slave periodic time base. </p>
<p><b>For internal use only.</b></p>
<p>The periodic timer tick is cascaded from a software timer managed from the master aperiodic time base; in other words, periodic timing is emulated by software timers running in aperiodic timing mode. There may be several concurrent periodic time bases (albeit a single aperiodic time base - i.e. the master one called "nktbase" - may exist at any point in time).</p>
<p>This routine informs all active timers that the clock has been updated by processing the timer wheel. Elapsed timer actions will be fired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mtimer</em>&nbsp;</td><td>The address of the cascading timer running in the master time base which announced the tick.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Interrupt service routine, nklock locked, interrupts off</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only active timers are inserted into the timer wheel. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 10 2012 20:41:24 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
