<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: CAN Devices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<h1>CAN Devices<br/>
<small>
[<a class="el" href="group__profiles.html">Device Profiles</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for CAN Devices:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtcan.png" border="0" alt="" usemap="#group____rtcan"/>
<map name="group____rtcan" id="group____rtcan">
<area shape="rect" id="node1" href="group__profiles.html" title="Device Profiles" alt="" coords="5,5,120,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime__std.html">can_bittime_std</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard bit-time parameters according to Bosch.  <a href="structcan__bittime__std.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime__btr.html">can_bittime_btr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hardware-specific BTR bit-times.  <a href="structcan__bittime__btr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime.html">can_bittime</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom CAN bit-time definition.  <a href="structcan__bittime.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__filter.html">can_filter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for reception of CAN messages.  <a href="structcan__filter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__can.html">sockaddr_can</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket address structure for the CAN address family.  <a href="structsockaddr__can.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__frame.html">can_frame</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw CAN frame.  <a href="structcan__frame.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtcan_8h.html">rtcan.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Real-Time Driver Model for RT-Socket-CAN, CAN device profile header. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga546620c7e758f003b24b7fdae4f97bd4"></a><!-- doxytag: member="rtcan::AF_CAN" ref="ga546620c7e758f003b24b7fdae4f97bd4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga546620c7e758f003b24b7fdae4f97bd4">AF_CAN</a>&nbsp;&nbsp;&nbsp;29</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN address family. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeac0c3db7a1e021f17987bcc76893849"></a><!-- doxytag: member="rtcan::PF_CAN" ref="gaeac0c3db7a1e021f17987bcc76893849" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaeac0c3db7a1e021f17987bcc76893849">PF_CAN</a>&nbsp;&nbsp;&nbsp;AF_CAN</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN protocol family. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gad981aa82a29d828882a2fb4c35c1cdd7">SOL_CAN_RAW</a>&nbsp;&nbsp;&nbsp;103</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN socket levels.  <a href="#gad981aa82a29d828882a2fb4c35c1cdd7"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4cb716102402e9be0b5919cd2dd6ead"></a><!-- doxytag: member="rtcan::can_id_t" ref="gad4cb716102402e9be0b5919cd2dd6ead" args="" -->
typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gad4cb716102402e9be0b5919cd2dd6ead">can_id_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of CAN id (see <a class="el" href="group__rtcan.html#CAN_xxx_MASK">CAN_xxx_MASK</a> and <a class="el" href="group__rtcan.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae3b8d6d39f9bbd387bf74031aba8f4f5"></a><!-- doxytag: member="rtcan::can_err_mask_t" ref="gae3b8d6d39f9bbd387bf74031aba8f4f5" args="" -->
typedef <a class="el" href="group__rtcan.html#gad4cb716102402e9be0b5919cd2dd6ead">can_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gae3b8d6d39f9bbd387bf74031aba8f4f5">can_err_mask_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of CAN error mask. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c314e1f81a7211a9778da835202a741"></a><!-- doxytag: member="rtcan::can_baudrate_t" ref="ga1c314e1f81a7211a9778da835202a741" args="" -->
typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Baudrate definition in bits per second. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94a6fb4128854d6fec6e0882df4374f2"></a><!-- doxytag: member="rtcan::can_bittime_type_t" ref="ga94a6fb4128854d6fec6e0882df4374f2" args="" -->
typedef enum <a class="el" href="group__rtcan.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga94a6fb4128854d6fec6e0882df4374f2">can_bittime_type_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga47a129d7188a7cd7b68fbf60ebbfd9e8"></a><!-- doxytag: member="rtcan::can_mode_t" ref="ga47a129d7188a7cd7b68fbf60ebbfd9e8" args="" -->
typedef enum <a class="el" href="group__rtcan.html#gac0d6cdda2cf4abb51116b86bc99acf99">CAN_MODE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga47a129d7188a7cd7b68fbf60ebbfd9e8">can_mode_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#CAN_MODE">CAN_MODE</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1db20ee5ae4803157e38db4b6c6150b"></a><!-- doxytag: member="rtcan::can_ctrlmode_t" ref="gaa1db20ee5ae4803157e38db4b6c6150b" args="" -->
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaa1db20ee5ae4803157e38db4b6c6150b">can_ctrlmode_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#CAN_CTRLMODE">CAN_CTRLMODE</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga046ddfab86ca47210233f254bc874c6d"></a><!-- doxytag: member="rtcan::can_state_t" ref="ga046ddfab86ca47210233f254bc874c6d" args="" -->
typedef enum <a class="el" href="group__rtcan.html#ga8680f5710e1a13d553067cc32c86226b">CAN_STATE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga046ddfab86ca47210233f254bc874c6d">can_state_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="group__rtcan.html#CAN_STATE">CAN_STATE</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcan__filter.html">can_filter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga95d9c00c42529e030dcc8d43a98127a2">can_filter_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for reception of CAN messages.  <a href="#ga95d9c00c42529e030dcc8d43a98127a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcan__frame.html">can_frame</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gace340cdd98cbfd2525c9d6b23cdd2188">can_frame_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw CAN frame.  <a href="#gace340cdd98cbfd2525c9d6b23cdd2188"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a> { <a class="el" href="group__rtcan.html#gga42c4f551b57f47d4e004c02505a01f71a160d7c514df2477f8016ed1bf5a6709f">CAN_BITTIME_STD</a>, 
<a class="el" href="group__rtcan.html#gga42c4f551b57f47d4e004c02505a01f71ae164a942c698440f2548bd82fea33e55">CAN_BITTIME_BTR</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Supported CAN bit-time types. </p>
 <a href="group__rtcan.html#ga42c4f551b57f47d4e004c02505a01f71">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
CAN operation modes</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp760e965317160106d81dfdf2ffff90ef"></a> <a class="anchor" id="CAN_MODE"></a> Modes into which CAN controllers can be set </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gac0d6cdda2cf4abb51116b86bc99acf99">CAN_MODE</a> { <a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790">CAN_MODE_STOP</a> =  0, 
<a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>, 
<a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e">CAN_MODE_SLEEP</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
CAN controller states</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbeee666541059166baa8758375561c32"></a> <a class="anchor" id="CAN_STATE"></a> States a CAN controller can be in. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga8680f5710e1a13d553067cc32c86226b">CAN_STATE</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67">CAN_STATE_ACTIVE</a> =  0, 
<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba8e8ffc38c3886c8ab4b7a6ebd24db2e1">CAN_STATE_BUS_WARNING</a>, 
<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba16806979589ee8f20ee84c767903b667">CAN_STATE_BUS_PASSIVE</a>, 
<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba679935a8710667fcb99423d217cd9959">CAN_STATE_BUS_OFF</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226bacc4b4039f38316b01662d775eeb981ff">CAN_STATE_SCANNING_BAUDRATE</a>, 
<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba644e7a441f2e607b93528d3128508cc8">CAN_STATE_STOPPED</a>, 
<a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba2bb74d448dac491e9cfcc7f7bcc14857">CAN_STATE_SLEEPING</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
CAN ID masks</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpdc1d13648799eb345ac952d96077d2be"></a> <a class="anchor" id="CAN_xxx_MASK"></a> Bit masks for masking CAN IDs </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83b943dca61d0aad5b07ec01c3317572"></a><!-- doxytag: member="rtcan::CAN_EFF_MASK" ref="ga83b943dca61d0aad5b07ec01c3317572" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga83b943dca61d0aad5b07ec01c3317572">CAN_EFF_MASK</a>&nbsp;&nbsp;&nbsp;0x1FFFFFFF</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit mask for extended CAN IDs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe4fc3f9cab58aeeb463861289e8ce93"></a><!-- doxytag: member="rtcan::CAN_SFF_MASK" ref="gafe4fc3f9cab58aeeb463861289e8ce93" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gafe4fc3f9cab58aeeb463861289e8ce93">CAN_SFF_MASK</a>&nbsp;&nbsp;&nbsp;0x000007FF</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit mask for standard CAN IDs. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
CAN ID flags</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp14cd9990cc0bd89a94d5749eb40704d4"></a> <a class="anchor" id="CAN_xxx_FLAG"></a> Flags within a CAN ID indicating special CAN frame attributes </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ae55ab3741140024858bd7b8762ea42"></a><!-- doxytag: member="rtcan::CAN_EFF_FLAG" ref="ga5ae55ab3741140024858bd7b8762ea42" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga5ae55ab3741140024858bd7b8762ea42">CAN_EFF_FLAG</a>&nbsp;&nbsp;&nbsp;0x80000000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended frame. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf324d65226057755175038a15d9bbd75"></a><!-- doxytag: member="rtcan::CAN_RTR_FLAG" ref="gaf324d65226057755175038a15d9bbd75" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaf324d65226057755175038a15d9bbd75">CAN_RTR_FLAG</a>&nbsp;&nbsp;&nbsp;0x40000000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remote transmission frame. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24df2eae50a2cef0f7f08c73a246a012"></a><!-- doxytag: member="rtcan::CAN_ERR_FLAG" ref="ga24df2eae50a2cef0f7f08c73a246a012" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga24df2eae50a2cef0f7f08c73a246a012">CAN_ERR_FLAG</a>&nbsp;&nbsp;&nbsp;0x20000000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error frame (see <a class="el" href="group__rtcan.html#Errors">Errors</a>), not valid in struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages.">can_filter</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5cb484fa2d90489f6b4e7a77c254c59f"></a><!-- doxytag: member="rtcan::CAN_INV_FILTER" ref="ga5cb484fa2d90489f6b4e7a77c254c59f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga5cb484fa2d90489f6b4e7a77c254c59f">CAN_INV_FILTER</a>&nbsp;&nbsp;&nbsp;CAN_ERR_FLAG</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert CAN filter definition, only valid in struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages.">can_filter</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Particular CAN protocols</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp7b577d0a81d3d775a98d0963ccf3b373"></a> <a class="anchor" id="CAN_PROTO"></a> Possible protocols for the PF_CAN protocol family</p>
<p>Currently only the RAW protocol is supported. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57682d9a1e4f4d90943dbaa683582bf5"></a><!-- doxytag: member="rtcan::CAN_RAW" ref="ga57682d9a1e4f4d90943dbaa683582bf5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga57682d9a1e4f4d90943dbaa683582bf5">CAN_RAW</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw protocol of <code>PF_CAN</code>, applicable to socket type <code>SOCK_RAW</code>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
CAN controller modes</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp6c55ad9e7f45d10972f34fd033dc8680"></a> <a class="anchor" id="CAN_CTRLMODE"></a> Special CAN controllers modes, which can be or'ed together.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>These modes are hardware-dependent. Please consult the hardware manual of the CAN controller for more detailed information. </dd></dl>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gae4ba49824d17e7d06300cb8b4a4bff45">CAN_CTRLMODE_LISTENONLY</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga19ec0cc4379e80c32cbd333cf7c145e9">CAN_CTRLMODE_LOOPBACK</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Timestamp switches</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp34b6790f0f944121855121121dbb08f7"></a> <a class="anchor" id="RTCAN_TIMESTAMPS"></a> Arguments to pass to <a class="el" href="group__rtcan.html#gaedd7bd75a1983735052fed62e101e5ce">RTCAN_RTIOC_TAKE_TIMESTAMP</a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae06ad16f505d1ec6c1e55d82ac82ef89"></a><!-- doxytag: member="rtcan::RTCAN_TAKE_NO_TIMESTAMPS" ref="gae06ad16f505d1ec6c1e55d82ac82ef89" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gae06ad16f505d1ec6c1e55d82ac82ef89">RTCAN_TAKE_NO_TIMESTAMPS</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch off taking timestamps. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae39894e7e6d107d4bab150cc0ef993c8"></a><!-- doxytag: member="rtcan::RTCAN_TAKE_TIMESTAMPS" ref="gae39894e7e6d107d4bab150cc0ef993c8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gae39894e7e6d107d4bab150cc0ef993c8">RTCAN_TAKE_TIMESTAMPS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do take timestamps. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RAW socket options</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpf64fde2e62c949159157cfdee8ea762c"></a> <a class="anchor" id="Rawsockopts"></a> Setting and getting CAN RAW socket options. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga87313c6e632294aa4582899a3bbc89e4">CAN_RAW_FILTER</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN filter definition.  <a href="#ga87313c6e632294aa4582899a3bbc89e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN error mask.  <a href="#ga451ba35aa4d0bef48cb7b0416f5b4367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaa7eb7dc3aa940a0aca20d3a564a147d9">CAN_RAW_LOOPBACK</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN TX loopback.  <a href="#gaa7eb7dc3aa940a0aca20d3a564a147d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga712942ca3d0d621184fb2019a24677c3">CAN_RAW_RECV_OWN_MSGS</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CAN receive own messages.  <a href="#ga712942ca3d0d621184fb2019a24677c3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
IOCTLs</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpa18f8b001f56d5e10d81e12685125407"></a> <a class="anchor" id="CANIOCTLs"></a> CAN device IOCTLs </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaee74ae50c8ea0a6aee277c6f124a3866">SIOCGIFINDEX</a>&nbsp;&nbsp;&nbsp;defined_by_kernel_header_file</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get CAN interface index by name.  <a href="#gaee74ae50c8ea0a6aee277c6f124a3866"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga7c070037c218b40de849ebf4d299f977">SIOCSCANBAUDRATE</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x01, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set baud rate.  <a href="#ga7c070037c218b40de849ebf4d299f977"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga9a3032f07b3a6a2f92eb2ba25a4ff8bf">SIOCGCANBAUDRATE</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x02, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get baud rate.  <a href="#ga9a3032f07b3a6a2f92eb2ba25a4ff8bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga4e9547dcb608fd0b8d5cf57f926e5176">SIOCSCANCUSTOMBITTIME</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x03, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set custom bit time parameter.  <a href="#ga4e9547dcb608fd0b8d5cf57f926e5176"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gab92b51127ca47c491069b9f3e5013a7f">SIOCGCANCUSTOMBITTIME</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x04, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get custum bit-time parameters.  <a href="#gab92b51127ca47c491069b9f3e5013a7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga72b56a34fe466bca858b1f5f401e1076">SIOCSCANMODE</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x05, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set operation mode of CAN controller.  <a href="#ga72b56a34fe466bca858b1f5f401e1076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga5b5f750db08d56f40489679f22236ef4">SIOCGCANSTATE</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x06, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current state of CAN controller.  <a href="#ga5b5f750db08d56f40489679f22236ef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga26fa69d2cded6e172b96b4a6dc3798df">SIOCSCANCTRLMODE</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x07, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set special controller modes.  <a href="#ga26fa69d2cded6e172b96b4a6dc3798df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaa78d64e69ffd68a20f93a6aa64393d6a">SIOCGCANCTRLMODE</a>&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x08, struct ifreq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get special controller modes.  <a href="#gaa78d64e69ffd68a20f93a6aa64393d6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaedd7bd75a1983735052fed62e101e5ce">RTCAN_RTIOC_TAKE_TIMESTAMP</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x09, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable storing a high precision timestamp upon reception of a CAN frame.  <a href="#gaedd7bd75a1983735052fed62e101e5ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gad8af08ea3624e8e9c464ff143fcb66c0">RTCAN_RTIOC_RCV_TIMEOUT</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0A, nanosecs_rel_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify a reception timeout for a socket.  <a href="#gad8af08ea3624e8e9c464ff143fcb66c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gad3758528585b2779e8949df671f1cf6c">RTCAN_RTIOC_SND_TIMEOUT</a>&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0B, nanosecs_rel_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify a transmission timeout for a socket.  <a href="#gad3758528585b2779e8949df671f1cf6c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Error mask</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpf0be135a9595bb41685bc587f6b1e7a8"></a> <a class="anchor" id="Errors"></a> Error class (mask) in <code>can_id</code> field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a> to be used with <a class="el" href="group__rtcan.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a>.</p>
<p><b>Note:</b> Error reporting is hardware dependent and most CAN controllers report less detailed error conditions than the SJA1000.</p>
<p><b>Note:</b> In case of a bus-off error condition (<a class="el" href="group__rtcan.html#ga8b0903e35c75de100b97a7b3e368b269">CAN_ERR_BUSOFF</a>), the CAN controller is <b>not</b> restarted automatically. It is the application's responsibility to react appropriately, e.g. calling <a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>.</p>
<p><b>Note:</b> Bus error interrupts (<a class="el" href="group__rtcan.html#ga0b068b1221129441b89967ee2ddb9f44">CAN_ERR_BUSERROR</a>) are enabled when an application is calling a <a class="el" href="group__rtcan.html#Recv">Recv</a> function on a socket listening on bus errors (using <a class="el" href="group__rtcan.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a>). After one bus error has occured, the interrupt will be disabled to allow the application time for error processing and to efficiently avoid bus error interrupt flooding. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga168d1c5d468bad5e52ccbd70c5f37986"></a><!-- doxytag: member="rtcan::CAN_ERR_TX_TIMEOUT" ref="ga168d1c5d468bad5e52ccbd70c5f37986" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga168d1c5d468bad5e52ccbd70c5f37986">CAN_ERR_TX_TIMEOUT</a>&nbsp;&nbsp;&nbsp;0x00000001U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TX timeout (netdevice driver). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa79a977211fe6534a627541f71373df0"></a><!-- doxytag: member="rtcan::CAN_ERR_LOSTARB" ref="gaa79a977211fe6534a627541f71373df0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaa79a977211fe6534a627541f71373df0">CAN_ERR_LOSTARB</a>&nbsp;&nbsp;&nbsp;0x00000002U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lost arbitration (see <a class="el" href="group__rtcan.html#Error0">data[0]</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8086092a2e40c1b0429caaad3b2c8675"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL" ref="ga8086092a2e40c1b0429caaad3b2c8675" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga8086092a2e40c1b0429caaad3b2c8675">CAN_ERR_CRTL</a>&nbsp;&nbsp;&nbsp;0x00000004U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controller problems (see <a class="el" href="group__rtcan.html#Error1">data[1]</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fdfaa2091c61c2db8caa7a51e8c0037"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT" ref="ga0fdfaa2091c61c2db8caa7a51e8c0037" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga0fdfaa2091c61c2db8caa7a51e8c0037">CAN_ERR_PROT</a>&nbsp;&nbsp;&nbsp;0x00000008U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Protocol violations (see <a class="el" href="group__rtcan.html#Error2">data[2]</a>, <a class="el" href="/home/gilles/files/perso/src/xenomai/xenomai-2.6/include/rtdm/rtcan.h.html#Error3">data[3]</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0026f916a985610cc449ffa6a31445f"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX" ref="gaf0026f916a985610cc449ffa6a31445f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaf0026f916a985610cc449ffa6a31445f">CAN_ERR_TRX</a>&nbsp;&nbsp;&nbsp;0x00000010U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transceiver status (see <a class="el" href="group__rtcan.html#Error4">data[4]</a>). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadbe83f5e81c1c8c767daaf97c5849017"></a><!-- doxytag: member="rtcan::CAN_ERR_ACK" ref="gadbe83f5e81c1c8c767daaf97c5849017" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gadbe83f5e81c1c8c767daaf97c5849017">CAN_ERR_ACK</a>&nbsp;&nbsp;&nbsp;0x00000020U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Received no ACK on transmission. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b0903e35c75de100b97a7b3e368b269"></a><!-- doxytag: member="rtcan::CAN_ERR_BUSOFF" ref="ga8b0903e35c75de100b97a7b3e368b269" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga8b0903e35c75de100b97a7b3e368b269">CAN_ERR_BUSOFF</a>&nbsp;&nbsp;&nbsp;0x00000040U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bus off. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b068b1221129441b89967ee2ddb9f44"></a><!-- doxytag: member="rtcan::CAN_ERR_BUSERROR" ref="ga0b068b1221129441b89967ee2ddb9f44" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga0b068b1221129441b89967ee2ddb9f44">CAN_ERR_BUSERROR</a>&nbsp;&nbsp;&nbsp;0x00000080U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bus error (may flood!). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54583090d19940d761a224bc0801ec6a"></a><!-- doxytag: member="rtcan::CAN_ERR_RESTARTED" ref="ga54583090d19940d761a224bc0801ec6a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga54583090d19940d761a224bc0801ec6a">CAN_ERR_RESTARTED</a>&nbsp;&nbsp;&nbsp;0x00000100U</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controller restarted. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4061a08b8c5aa6de3bb390efd3b6bd6"></a><!-- doxytag: member="rtcan::CAN_ERR_MASK" ref="gad4061a08b8c5aa6de3bb390efd3b6bd6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gad4061a08b8c5aa6de3bb390efd3b6bd6">CAN_ERR_MASK</a>&nbsp;&nbsp;&nbsp;0x1FFFFFFFU</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Omit EFF, RTR, ERR flags. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Arbitration lost error</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpee72c88cd2af8e954beb61937781c7a8"></a> <a class="anchor" id="Error0"></a> Error in the data[0] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga7fa1bc55bccfadf780c0556c7d4d7fef">CAN_ERR_LOSTARB_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified  <a href="#ga7fa1bc55bccfadf780c0556c7d4d7fef"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Controller problems</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpac5727a5d110ebda71b15fd5e9af5ddb"></a> <a class="anchor" id="Error1"></a> Error in the data[1] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafcdc17774047f27e70f3c39f6fb66076"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_UNSPEC" ref="gafcdc17774047f27e70f3c39f6fb66076" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gafcdc17774047f27e70f3c39f6fb66076">CAN_ERR_CRTL_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23d6f05d55b62fffdbd0a50969bc2d04"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_RX_OVERFLOW" ref="ga23d6f05d55b62fffdbd0a50969bc2d04" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga23d6f05d55b62fffdbd0a50969bc2d04">CAN_ERR_CRTL_RX_OVERFLOW</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RX buffer overflow. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1412f1e2cc4f23334ed5ea766d12006"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_TX_OVERFLOW" ref="gab1412f1e2cc4f23334ed5ea766d12006" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gab1412f1e2cc4f23334ed5ea766d12006">CAN_ERR_CRTL_TX_OVERFLOW</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TX buffer overflow. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae93958bbabe5e2e6d328d8fa5d491a96"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_RX_WARNING" ref="gae93958bbabe5e2e6d328d8fa5d491a96" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gae93958bbabe5e2e6d328d8fa5d491a96">CAN_ERR_CRTL_RX_WARNING</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached warning level for RX errors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab46d1dddb458203ca07e0c351275c549"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_TX_WARNING" ref="gab46d1dddb458203ca07e0c351275c549" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gab46d1dddb458203ca07e0c351275c549">CAN_ERR_CRTL_TX_WARNING</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached warning level for TX errors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga853db0a1bf833caea89e3597a0123c11"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_RX_PASSIVE" ref="ga853db0a1bf833caea89e3597a0123c11" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga853db0a1bf833caea89e3597a0123c11">CAN_ERR_CRTL_RX_PASSIVE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached passive level for RX errors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29185de9d3b35414a729af6e0fad6574"></a><!-- doxytag: member="rtcan::CAN_ERR_CRTL_TX_PASSIVE" ref="ga29185de9d3b35414a729af6e0fad6574" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga29185de9d3b35414a729af6e0fad6574">CAN_ERR_CRTL_TX_PASSIVE</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reached passive level for TX errors <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Protocol error type</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbfa8d907f596cb6d5845484db7387ded"></a> <a class="anchor" id="Error2"></a> Error in the data[2] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6cf7ee3a3d83315ed2589bb3bdb816b3"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_UNSPEC" ref="ga6cf7ee3a3d83315ed2589bb3bdb816b3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga6cf7ee3a3d83315ed2589bb3bdb816b3">CAN_ERR_PROT_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0443c62a7e861f429f51c7bb6dc4ee23"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_BIT" ref="ga0443c62a7e861f429f51c7bb6dc4ee23" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga0443c62a7e861f429f51c7bb6dc4ee23">CAN_ERR_PROT_BIT</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">single bit error <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8f76071caf3ac10abb88be4347b9625"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_FORM" ref="gae8f76071caf3ac10abb88be4347b9625" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gae8f76071caf3ac10abb88be4347b9625">CAN_ERR_PROT_FORM</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">frame format error <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31af2ea01de879fb1d153cb6c0d642f8"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_STUFF" ref="ga31af2ea01de879fb1d153cb6c0d642f8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga31af2ea01de879fb1d153cb6c0d642f8">CAN_ERR_PROT_STUFF</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bit stuffing error <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b469132ce858c4a0222e367b986343a"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_BIT0" ref="ga1b469132ce858c4a0222e367b986343a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga1b469132ce858c4a0222e367b986343a">CAN_ERR_PROT_BIT0</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unable to send dominant bit <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13e44854f6873a4a08ba2c9de0544471"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_BIT1" ref="ga13e44854f6873a4a08ba2c9de0544471" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga13e44854f6873a4a08ba2c9de0544471">CAN_ERR_PROT_BIT1</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unable to send recessive bit <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c02b06cad0d95b340c1b6294a5f9f9f"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_OVERLOAD" ref="ga0c02b06cad0d95b340c1b6294a5f9f9f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga0c02b06cad0d95b340c1b6294a5f9f9f">CAN_ERR_PROT_OVERLOAD</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bus overload <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga460ee0be98290e6916f85c8651d6de05"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_ACTIVE" ref="ga460ee0be98290e6916f85c8651d6de05" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga460ee0be98290e6916f85c8651d6de05">CAN_ERR_PROT_ACTIVE</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">active error announcement <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabee807ce2e8ccf6eafc9b6f73a9315fb"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_TX" ref="gabee807ce2e8ccf6eafc9b6f73a9315fb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gabee807ce2e8ccf6eafc9b6f73a9315fb">CAN_ERR_PROT_TX</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">error occured on transmission <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Protocol error location</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp8588d528005f5bada92aa41bf11cef30"></a> <a class="anchor" id="Error4"></a> Error in the data[4] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ac83a947ca929b857af6352300ad6d8"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_UNSPEC" ref="ga4ac83a947ca929b857af6352300ad6d8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga4ac83a947ca929b857af6352300ad6d8">CAN_ERR_PROT_LOC_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7a2392801977b667a4d39083d0c92c3"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_SOF" ref="gaa7a2392801977b667a4d39083d0c92c3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaa7a2392801977b667a4d39083d0c92c3">CAN_ERR_PROT_LOC_SOF</a>&nbsp;&nbsp;&nbsp;0x03</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start of frame <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0592a90c8dba2c8102479e184dcd6c62"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ID28_21" ref="ga0592a90c8dba2c8102479e184dcd6c62" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga0592a90c8dba2c8102479e184dcd6c62">CAN_ERR_PROT_LOC_ID28_21</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 28 - 21 (SFF: 10 - 3). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga240923d7f939dd08d2e4f434468e3006"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ID20_18" ref="ga240923d7f939dd08d2e4f434468e3006" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga240923d7f939dd08d2e4f434468e3006">CAN_ERR_PROT_LOC_ID20_18</a>&nbsp;&nbsp;&nbsp;0x06</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 20 - 18 (SFF: 2 - 0 ). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad70fa4d644d5b71f8891de051643226a"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_SRTR" ref="gad70fa4d644d5b71f8891de051643226a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gad70fa4d644d5b71f8891de051643226a">CAN_ERR_PROT_LOC_SRTR</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">substitute RTR (SFF: RTR) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4fe7a2839d2ca31e8dd383564b1865c1"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_IDE" ref="ga4fe7a2839d2ca31e8dd383564b1865c1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga4fe7a2839d2ca31e8dd383564b1865c1">CAN_ERR_PROT_LOC_IDE</a>&nbsp;&nbsp;&nbsp;0x05</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">identifier extension <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb436ab756394e8844a3925edd92b95c"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ID17_13" ref="gabb436ab756394e8844a3925edd92b95c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gabb436ab756394e8844a3925edd92b95c">CAN_ERR_PROT_LOC_ID17_13</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 17-13. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd6cd3681ebf245896d282daabdac0b7"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ID12_05" ref="gafd6cd3681ebf245896d282daabdac0b7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gafd6cd3681ebf245896d282daabdac0b7">CAN_ERR_PROT_LOC_ID12_05</a>&nbsp;&nbsp;&nbsp;0x0F</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 12-5. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00bc04bfcae8d6486aa149cd19dd6102"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ID04_00" ref="ga00bc04bfcae8d6486aa149cd19dd6102" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga00bc04bfcae8d6486aa149cd19dd6102">CAN_ERR_PROT_LOC_ID04_00</a>&nbsp;&nbsp;&nbsp;0x0E</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID bits 4-0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79567d5df1287ccdd1966d092b5e047c"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_RTR" ref="ga79567d5df1287ccdd1966d092b5e047c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga79567d5df1287ccdd1966d092b5e047c">CAN_ERR_PROT_LOC_RTR</a>&nbsp;&nbsp;&nbsp;0x0C</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RTR. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13aa190099e1600314bb8e46e0a693ce"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_RES1" ref="ga13aa190099e1600314bb8e46e0a693ce" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga13aa190099e1600314bb8e46e0a693ce">CAN_ERR_PROT_LOC_RES1</a>&nbsp;&nbsp;&nbsp;0x0D</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reserved bit 1 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe744ebfd9a71b557d3059bc3f8aee56"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_RES0" ref="gafe744ebfd9a71b557d3059bc3f8aee56" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gafe744ebfd9a71b557d3059bc3f8aee56">CAN_ERR_PROT_LOC_RES0</a>&nbsp;&nbsp;&nbsp;0x09</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reserved bit 0 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2aa0ab15f3f4fc974653ff556688046a"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_DLC" ref="ga2aa0ab15f3f4fc974653ff556688046a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga2aa0ab15f3f4fc974653ff556688046a">CAN_ERR_PROT_LOC_DLC</a>&nbsp;&nbsp;&nbsp;0x0B</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">data length code <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1877b10333d3805f2ea1ef9195a8dee1"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_DATA" ref="ga1877b10333d3805f2ea1ef9195a8dee1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga1877b10333d3805f2ea1ef9195a8dee1">CAN_ERR_PROT_LOC_DATA</a>&nbsp;&nbsp;&nbsp;0x0A</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">data section <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e56b5931c70b6ecf21a3b7d9ceebe16"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_CRC_SEQ" ref="ga1e56b5931c70b6ecf21a3b7d9ceebe16" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga1e56b5931c70b6ecf21a3b7d9ceebe16">CAN_ERR_PROT_LOC_CRC_SEQ</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CRC sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga893a0c29cb622265c5d22ba7f26575a2"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_CRC_DEL" ref="ga893a0c29cb622265c5d22ba7f26575a2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga893a0c29cb622265c5d22ba7f26575a2">CAN_ERR_PROT_LOC_CRC_DEL</a>&nbsp;&nbsp;&nbsp;0x18</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CRC delimiter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga14988a58a4514b44061ab5b942c6bbdf"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ACK" ref="ga14988a58a4514b44061ab5b942c6bbdf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga14988a58a4514b44061ab5b942c6bbdf">CAN_ERR_PROT_LOC_ACK</a>&nbsp;&nbsp;&nbsp;0x19</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ACK slot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e928e081ef83a83c2885259fc0a6002"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_ACK_DEL" ref="ga8e928e081ef83a83c2885259fc0a6002" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga8e928e081ef83a83c2885259fc0a6002">CAN_ERR_PROT_LOC_ACK_DEL</a>&nbsp;&nbsp;&nbsp;0x1B</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ACK delimiter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga811713c9831116e6e6c42631fb7d287a"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_EOF" ref="ga811713c9831116e6e6c42631fb7d287a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga811713c9831116e6e6c42631fb7d287a">CAN_ERR_PROT_LOC_EOF</a>&nbsp;&nbsp;&nbsp;0x1A</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end of frame <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac52eb448c0ec04421f0e21ccf9a496a0"></a><!-- doxytag: member="rtcan::CAN_ERR_PROT_LOC_INTERM" ref="gac52eb448c0ec04421f0e21ccf9a496a0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gac52eb448c0ec04421f0e21ccf9a496a0">CAN_ERR_PROT_LOC_INTERM</a>&nbsp;&nbsp;&nbsp;0x12</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">intermission <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2169eab29b3c954598fe6780d98b479a"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_UNSPEC" ref="ga2169eab29b3c954598fe6780d98b479a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga2169eab29b3c954598fe6780d98b479a">CAN_ERR_TRX_UNSPEC</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0000 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac39d4c89032cba5c08981182e297c7d7"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANH_NO_WIRE" ref="gac39d4c89032cba5c08981182e297c7d7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gac39d4c89032cba5c08981182e297c7d7">CAN_ERR_TRX_CANH_NO_WIRE</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0100 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga294393d4f39d4476d0c57876c3504a98"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANH_SHORT_TO_BAT" ref="ga294393d4f39d4476d0c57876c3504a98" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga294393d4f39d4476d0c57876c3504a98">CAN_ERR_TRX_CANH_SHORT_TO_BAT</a>&nbsp;&nbsp;&nbsp;0x05</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0101 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85ab738e9c73d380f96371f195aa41ab"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANH_SHORT_TO_VCC" ref="ga85ab738e9c73d380f96371f195aa41ab" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga85ab738e9c73d380f96371f195aa41ab">CAN_ERR_TRX_CANH_SHORT_TO_VCC</a>&nbsp;&nbsp;&nbsp;0x06</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0110 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga325c4d192a7de24a61b8fcca1d434669"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANH_SHORT_TO_GND" ref="ga325c4d192a7de24a61b8fcca1d434669" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga325c4d192a7de24a61b8fcca1d434669">CAN_ERR_TRX_CANH_SHORT_TO_GND</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0000 0111 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ecc59939f560d7e018af307df03a370"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANL_NO_WIRE" ref="ga1ecc59939f560d7e018af307df03a370" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga1ecc59939f560d7e018af307df03a370">CAN_ERR_TRX_CANL_NO_WIRE</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0100 0000 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4ec9ec512befde085f5a7701d0813fe"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_BAT" ref="gaf4ec9ec512befde085f5a7701d0813fe" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaf4ec9ec512befde085f5a7701d0813fe">CAN_ERR_TRX_CANL_SHORT_TO_BAT</a>&nbsp;&nbsp;&nbsp;0x50</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0101 0000 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace999081029fcd690f89c76aa8738122"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_VCC" ref="gace999081029fcd690f89c76aa8738122" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gace999081029fcd690f89c76aa8738122">CAN_ERR_TRX_CANL_SHORT_TO_VCC</a>&nbsp;&nbsp;&nbsp;0x60</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0110 0000 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga428b96738439b9df662a999f1a5f9ffd"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_GND" ref="ga428b96738439b9df662a999f1a5f9ffd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#ga428b96738439b9df662a999f1a5f9ffd">CAN_ERR_TRX_CANL_SHORT_TO_GND</a>&nbsp;&nbsp;&nbsp;0x70</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0111 0000 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaed57dcbd07a56050c8915fcd8bd5ba8"></a><!-- doxytag: member="rtcan::CAN_ERR_TRX_CANL_SHORT_TO_CANH" ref="gaaed57dcbd07a56050c8915fcd8bd5ba8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtcan.html#gaaed57dcbd07a56050c8915fcd8bd5ba8">CAN_ERR_TRX_CANL_SHORT_TO_CANH</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1000 0000 <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is the common interface a RTDM-compliant CAN device has to provide. Feel free to report bugs and comments on this profile to the "Socketcan" mailing list (<a href="mailto:Socketcan-core@lists.berlios.de">Socketcan-core@lists.berlios.de</a>) or directly to the authors (<a href="mailto:wg@grandegger.com">wg@grandegger.com</a> or <a href="mailto:Sebastian.Smolorz@stud.uni-hannover.de">Sebastian.Smolorz@stud.uni-hannover.de</a>).</p>
<p><b>Profile</b> <b>Revision:</b> 2 <br/>
 <br/>
 </p>
<dl class="user"><dt><b>Device Characteristics</b></dt><dd><br/>
 <a class="el" href="structrtdm__device.html#af459bf86f0d037c99bb669f627d78764">Device Flags</a>: <code>RTDM_PROTOCOL_DEVICE</code> <br/>
 <br/>
 <a class="el" href="structrtdm__device.html#ae58c050e09a79b277f718d796eda2072">Protocol Family</a>: <code>PF_CAN</code> <br/>
 <br/>
 <a class="el" href="structrtdm__device.html#a02552f2d91052bd801576b3a132ba3f9">Socket Type</a>: <code>SOCK_RAW</code> <br/>
 <br/>
 <a class="el" href="structrtdm__device.html#a94aa3100258b43c812c5240b55777f07">Device Class</a>: <code>RTDM_CLASS_CAN</code> <br/>
 <br/>
</dd></dl>
<dl class="user"><dt><b>Supported Operations</b></dt><dd><br/>
 <b>Socket</b> <br/>
 Environments: non-RT (RT optional, deprecated)<br/>
 <br/>
 Specific return values:<ul>
<li>-EPROTONOSUPPORT (Protocol is not supported by the driver. See <a class="el" href="group__rtcan.html#CAN_PROTO">CAN protocols</a> for possible protocols.)</li>
</ul>
<br/>
 <br/>
 <b>Close</b> <br/>
 Blocking calls to any of the <a class="el" href="group__rtcan.html#Send">Send</a> or <a class="el" href="group__rtcan.html#Recv">Receive</a> functions will be unblocked when the socket is closed and return with an error. <br/>
 <br/>
 Environments: non-RT (RT optional, deprecated)<br/>
 <br/>
 Specific return values: none <br/>
 <br/>
 <br/>
 <b>IOCTL</b> <br/>
 Mandatory Environments: see <a class="el" href="group__rtcan.html#CANIOCTLs">below</a> <br/>
 Specific return values: see <a class="el" href="group__rtcan.html#CANIOCTLs">below</a> <br/>
 <br/>
 <br/>
 <a class="anchor" id="Bind"></a> <b>Bind</b> <br/>
 Binds a socket to one or all CAN devices (see struct <a class="el" href="structsockaddr__can.html" title="Socket address structure for the CAN address family.">sockaddr_can</a>). If a filter list has been defined with setsockopt (see <a class="el" href="group__rtcan.html#Sockopts">Sockopts</a>), it will be used upon reception of CAN frames to decide whether the bound socket will receive a frame. If no filter has been defined, the socket will receive <b>all</b> CAN frames on the specified interface(s). <br/>
 <br/>
 Binding to special interface index <code>0</code> will make the socket receive CAN frames from all CAN interfaces. <br/>
 <br/>
 Binding to an interface index is also relevant for the <a class="el" href="group__rtcan.html#Send">Send</a> functions because they will transmit a message over the interface the socket is bound to when no socket address is given to them. <br/>
 <br/>
 <br/>
 Environments: non-RT (RT optional)<br/>
 <br/>
 Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-ENOMEM (Not enough memory to fulfill the operation)</li>
<li>-EINVAL (Invalid address family, or invalid length of address structure)</li>
<li>-ENODEV (Invalid CAN interface index)</li>
<li>-ENOSPC (No enough space for filter list)</li>
<li>-EBADF (Socket is about to be closed)</li>
<li>-EAGAIN (Too many receivers. Old binding (if any) is still active. Close some sockets and try again.)</li>
</ul>
<br/>
 <br/>
 <a class="anchor" id="Sockopts"></a> <b>Setsockopt, Getsockopt</b><br/>
 These functions allow to set and get various socket options. Currently, only CAN raw sockets are supported. <br/>
 <br/>
 Supported Levels and Options: <br/>
<ul>
<li>Level <b>SOL_CAN_RAW</b> : CAN RAW protocol (see <a class="el" href="group__rtcan.html#ga57682d9a1e4f4d90943dbaa683582bf5">CAN_RAW</a>)<ul>
<li>Option <a class="el" href="group__rtcan.html#ga87313c6e632294aa4582899a3bbc89e4">CAN_RAW_FILTER</a> : CAN filter list</li>
<li>Option <a class="el" href="group__rtcan.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a> : CAN error mask</li>
<li>Option <a class="el" href="group__rtcan.html#gaa7eb7dc3aa940a0aca20d3a564a147d9">CAN_RAW_LOOPBACK</a> : CAN TX loopback to local sockets</li>
</ul>
</li>
</ul>
<br/>
 Environments: non-RT (RT optional)<br/>
 Specific return values: see links to options above. <br/>
 <br/>
 <br/>
 <a class="anchor" id="Recv"></a> <b>Recv, Recvfrom, Recvmsg</b> <br/>
 These functions receive CAN messages from a socket. Only one message per call can be received, so only one buffer with the correct length must be passed. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>. <br/>
 <br/>
 Unlike a call to one of the <a class="el" href="group__rtcan.html#Send">Send</a> functions, a Recv function will not return with an error if an interface is down (due to bus-off or setting of stop mode) or in sleep mode. Moreover, in such a case there may still be some CAN messages in the socket buffer which could be read out successfully. <br/>
 <br/>
 It is possible to receive a high precision timestamp with every CAN message. The condition is a former instruction to the socket via <a class="el" href="group__rtcan.html#gaedd7bd75a1983735052fed62e101e5ce">RTCAN_RTIOC_TAKE_TIMESTAMP</a>. The timestamp will be copied to the <code>msg_control</code> buffer of <code>struct msghdr</code> if it points to a valid memory location with size of <a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a>. If this is a NULL pointer the timestamp will be discarded silently. <br/>
 <br/>
 <b>Note:</b> A <code>msg_controllen</code> of <code>0</code> upon completion of the function call indicates that no timestamp is available for that message. <br/>
 <br/>
 Supported Flags [in]:<ul>
<li>MSG_DONTWAIT (By setting this flag the operation will only succeed if it would not block, i.e. if there is a message in the socket buffer. This flag takes precedence over a timeout specified by <a class="el" href="group__rtcan.html#gad8af08ea3624e8e9c464ff143fcb66c0">RTCAN_RTIOC_RCV_TIMEOUT</a>.)</li>
<li>MSG_PEEK (Receive a message but leave it in the socket buffer. The next receive operation will get that message again.)</li>
</ul>
<br/>
 Supported Flags [out]: none <br/>
 <br/>
 Environments: RT (non-RT optional)<br/>
 <br/>
 Specific return values:<ul>
<li>Non-negative value (Indicating the successful reception of a CAN message. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a> regardless of the actual size of the payload.)</li>
<li>-EFAULT (It was not possible to access user space memory area at one of the specified addresses.)</li>
<li>-EINVAL (Unsupported flag detected, or invalid length of socket address buffer, or invalid length of message control buffer)</li>
<li>-EMSGSIZE (Zero or more than one iovec buffer passed, or buffer too small)</li>
<li>-EAGAIN (No data available in non-blocking mode)</li>
<li>-EBADF (Socket was closed.)</li>
<li>-EINTR (Operation was interrupted explicitly or by signal.)</li>
<li>-ETIMEDOUT (Timeout)</li>
</ul>
<br/>
 <br/>
 <a class="anchor" id="Send"></a> <b>Send, Sendto, Sendmsg</b> <br/>
 These functions send out CAN messages. Only one message per call can be transmitted, so only one buffer with the correct length must be passed. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a>. <br/>
 <br/>
 The following only applies to <code>SOCK_RAW:</code> If a socket address of struct <a class="el" href="structsockaddr__can.html" title="Socket address structure for the CAN address family.">sockaddr_can</a> is given, only <code>can_ifindex</code> is used. It is also possible to omit the socket address. Then the interface the socket is bound to will be used for sending messages. <br/>
 <br/>
 If an interface goes down (due to bus-off or setting of stop mode) all senders that were blocked on this interface will be woken up. <br/>
 <br/>
 <br/>
 Supported Flags:<ul>
<li>MSG_DONTWAIT (By setting this flag the transmit operation will only succeed if it would not block. This flag takes precedence over a timeout specified by <a class="el" href="group__rtcan.html#gad3758528585b2779e8949df671f1cf6c">RTCAN_RTIOC_SND_TIMEOUT</a>.)</li>
</ul>
Environments: RT (non-RT optional)<br/>
 <br/>
 Specific return values:<ul>
<li>Non-negative value equal to given buffer size (Indicating the successful completion of the function call. See also note.)</li>
<li>-EOPNOTSUPP (MSG_OOB flag is not supported.)</li>
<li>-EINVAL (Unsupported flag detected <em>or:</em> Invalid length of socket address <em>or:</em> Invalid address family <em>or:</em> Data length code of CAN frame not between 0 and 15 <em>or:</em> CAN standard frame has got an ID not between 0 and 2031)</li>
<li>-EMSGSIZE (Zero or more than one buffer passed or invalid size of buffer)</li>
<li>-EFAULT (It was not possible to access user space memory area at one of the specified addresses.)</li>
<li>-ENXIO (Invalid CAN interface index - <code>0</code> is not allowed here - or socket not bound or rather bound to all interfaces.)</li>
<li>-ENETDOWN (Controller is bus-off or in stopped state.)</li>
<li>-ECOMM (Controller is sleeping)</li>
<li>-EAGAIN (Cannot transmit without blocking but a non-blocking call was requested.)</li>
<li>-EINTR (Operation was interrupted explicitly or by signal)</li>
<li>-EBADF (Socket was closed.)</li>
<li>-ETIMEDOUT (Timeout)</li>
</ul>
<b>Note:</b> A successful completion of the function call does not implicate a successful transmission of the message. </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gae4ba49824d17e7d06300cb8b4a4bff45"></a><!-- doxytag: member="rtcan.h::CAN_CTRLMODE_LISTENONLY" ref="gae4ba49824d17e7d06300cb8b4a4bff45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_CTRLMODE_LISTENONLY&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Listen-Only mode</p>
<p>In this mode the CAN controller would give no acknowledge to the CAN-bus, even if a message is received successfully and messages would not be transmitted. This mode might be useful for bus-monitoring, hot-plugging or throughput analysis. </p>

</div>
</div>
<a class="anchor" id="ga19ec0cc4379e80c32cbd333cf7c145e9"></a><!-- doxytag: member="rtcan.h::CAN_CTRLMODE_LOOPBACK" ref="ga19ec0cc4379e80c32cbd333cf7c145e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_CTRLMODE_LOOPBACK&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loopback mode</p>
<p>In this mode the CAN controller does an internal loop-back, a message is transmitted and simultaneously received. That mode can be used for self test operation. </p>

</div>
</div>
<a class="anchor" id="ga7fa1bc55bccfadf780c0556c7d4d7fef"></a><!-- doxytag: member="rtcan.h::CAN_ERR_LOSTARB_UNSPEC" ref="ga7fa1bc55bccfadf780c0556c7d4d7fef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_ERR_LOSTARB_UNSPEC&nbsp;&nbsp;&nbsp;0x00</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unspecified </p>
<p>else bit number in bitstream </p>

</div>
</div>
<a class="anchor" id="ga451ba35aa4d0bef48cb7b0416f5b4367"></a><!-- doxytag: member="rtcan.h::CAN_RAW_ERR_FILTER" ref="ga451ba35aa4d0bef48cb7b0416f5b4367" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_ERR_FILTER&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CAN error mask. </p>
<p>A CAN error mask (see <a class="el" href="group__rtcan.html#Errors">Errors</a>) can be set with <code>setsockopt</code>. This mask is then used to decide if error frames are delivered to this socket in case of error condidtions. The error frames are marked with the <a class="el" href="group__rtcan.html#ga24df2eae50a2cef0f7f08c73a246a012">CAN_ERR_FLAG</a> of <a class="el" href="group__rtcan.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a> and must be handled by the application properly. A detailed description of the errors can be found in the <code>can_id</code> and the <code>data</code> fields of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame.">can_frame</a> (see <a class="el" href="group__rtcan.html#Errors">Errors</a> for futher details).</p>
<p><br/>
 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>CAN_RAW_ERR_FILTER</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to error mask of type can_err_mask_t.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>Size of error mask: sizeof(can_err_mask_t).</td></tr>
  </table>
  </dd>
</dl>
<p>Environments: non-RT (RT optional)<br/>
 <br/>
 Specific return values:</p>
<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-EINVAL (Invalid length "optlen")</li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a16">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga87313c6e632294aa4582899a3bbc89e4"></a><!-- doxytag: member="rtcan.h::CAN_RAW_FILTER" ref="ga87313c6e632294aa4582899a3bbc89e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_FILTER&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CAN filter definition. </p>
<p>A CAN raw filter list with elements of struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages.">can_filter</a> can be installed with <code>setsockopt</code>. This list is used upon reception of CAN frames to decide whether the bound socket will receive a frame. An empty filter list can also be defined using optlen = 0, which is recommanded for write-only sockets. <br/>
 If the socket was already bound with <a class="el" href="group__rtcan.html#Bind">Bind</a>, the old filter list gets replaced with the new one. Be aware that already received, but not read out CAN frames may stay in the socket buffer. <br/>
 <br/>
 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>CAN_RAW_FILTER</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to array of struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages.">can_filter</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>Size of filter list: count * sizeof( struct can_filter). <br/>
 Environments: non-RT (RT optional)<br/>
 <br/>
 Specific return values:</p>
<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-ENOMEM (Not enough memory to fulfill the operation)</li>
<li>-EINVAL (Invalid length "optlen")</li>
<li>-ENOSPC (No space to store filter list, check RT-Socket-CAN kernel parameters)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcan__rtt_8c-example.html#a15">rtcan_rtt.c</a>, <a class="el" href="rtcanrecv_8c-example.html#a17">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a15">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa7eb7dc3aa940a0aca20d3a564a147d9"></a><!-- doxytag: member="rtcan.h::CAN_RAW_LOOPBACK" ref="gaa7eb7dc3aa940a0aca20d3a564a147d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_LOOPBACK&nbsp;&nbsp;&nbsp;0x3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CAN TX loopback. </p>
<p>The TX loopback to other local sockets can be selected with this <code>setsockopt</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The TX loopback feature must be enabled in the kernel and then the loopback to other local TX sockets is enabled by default.</dd></dl>
<p><br/>
 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optname</em>&nbsp;</td><td><b>CAN_RAW_LOOPBACK</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to integer value.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optlen</em>&nbsp;</td><td>Size of int: sizeof(int).</td></tr>
  </table>
  </dd>
</dl>
<p>Environments: non-RT (RT optional)<br/>
 <br/>
 Specific return values:</p>
<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-EINVAL (Invalid length "optlen")</li>
<li>-EOPNOTSUPP (not supported, check RT-Socket-CAN kernel parameters). </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcansend_8c-example.html#a13">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga712942ca3d0d621184fb2019a24677c3"></a><!-- doxytag: member="rtcan.h::CAN_RAW_RECV_OWN_MSGS" ref="ga712942ca3d0d621184fb2019a24677c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_RECV_OWN_MSGS&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CAN receive own messages. </p>
<p>Not supported by RT-Socket-CAN, but defined for compatibility with Socket-CAN. </p>

</div>
</div>
<a class="anchor" id="gad8af08ea3624e8e9c464ff143fcb66c0"></a><!-- doxytag: member="rtcan.h::RTCAN_RTIOC_RCV_TIMEOUT" ref="gad8af08ea3624e8e9c464ff143fcb66c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTCAN_RTIOC_RCV_TIMEOUT&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0A, nanosecs_rel_t)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify a reception timeout for a socket. </p>
<p>Defines a timeout for all receive operations via a socket which will take effect when one of the <a class="el" href="group__rtcan.html#Recv">receive functions</a> is called without the <code>MSG_DONTWAIT</code> flag set.</p>
<p>The default value for a newly created socket is an infinite timeout.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The setting of the timeout value is not done atomically to avoid locks. Please set the value before receiving messages from the socket.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> variable. The value is interpreted as relative timeout in nanoseconds in case of a positive value. See <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">Timeouts</a> for special timeouts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a19">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad3758528585b2779e8949df671f1cf6c"></a><!-- doxytag: member="rtcan.h::RTCAN_RTIOC_SND_TIMEOUT" ref="gad3758528585b2779e8949df671f1cf6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTCAN_RTIOC_SND_TIMEOUT&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x0B, nanosecs_rel_t)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify a transmission timeout for a socket. </p>
<p>Defines a timeout for all send operations via a socket which will take effect when one of the <a class="el" href="group__rtcan.html#Send">send functions</a> is called without the <code>MSG_DONTWAIT</code> flag set.</p>
<p>The default value for a newly created socket is an infinite timeout.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The setting of the timeout value is not done atomically to avoid locks. Please set the value before sending messages to the socket.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> variable. The value is interpreted as relative timeout in nanoseconds in case of a positive value. See <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">Timeouts</a> for special timeouts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcansend_8c-example.html#a17">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaedd7bd75a1983735052fed62e101e5ce"></a><!-- doxytag: member="rtcan.h::RTCAN_RTIOC_TAKE_TIMESTAMP" ref="gaedd7bd75a1983735052fed62e101e5ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTCAN_RTIOC_TAKE_TIMESTAMP&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x09, int)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable storing a high precision timestamp upon reception of a CAN frame. </p>
<p>A newly created socket takes no timestamps by default.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>int variable, see <a class="el" href="group__rtcan.html#RTCAN_TIMESTAMPS">Timestamp switches</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Activating taking timestamps only has an effect on newly received CAN messages from the bus. Frames that already are in the socket buffer do not have timestamps if it was deactivated before. See <a class="el" href="group__rtcan.html#Recv">Receive</a> for more details.</dd></dl>
<p>Rescheduling: never. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a20">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9a3032f07b3a6a2f92eb2ba25a4ff8bf"></a><!-- doxytag: member="rtcan.h::SIOCGCANBAUDRATE" ref="ga9a3032f07b3a6a2f92eb2ba25a4ff8bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANBAUDRATE&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x02, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get baud rate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of <a class="el" href="group__rtcan.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No baud rate was set yet.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gaa78d64e69ffd68a20f93a6aa64393d6a"></a><!-- doxytag: member="rtcan.h::SIOCGCANCTRLMODE" ref="gaa78d64e69ffd68a20f93a6aa64393d6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANCTRLMODE&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x08, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get special controller modes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#gaa1db20ee5ae4803157e38db4b6c6150b">can_ctrlmode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No baud rate was set yet.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="gab92b51127ca47c491069b9f3e5013a7f"></a><!-- doxytag: member="rtcan.h::SIOCGCANCUSTOMBITTIME" ref="gab92b51127ca47c491069b9f3e5013a7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANCUSTOMBITTIME&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x04, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get custum bit-time parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of struct <a class="el" href="structcan__bittime.html" title="Custom CAN bit-time definition.">can_bittime</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No baud rate was set yet.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga5b5f750db08d56f40489679f22236ef4"></a><!-- doxytag: member="rtcan.h::SIOCGCANSTATE" ref="ga5b5f750db08d56f40489679f22236ef4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANSTATE&nbsp;&nbsp;&nbsp;_IOWR(RTIOC_TYPE_CAN, 0x06, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current state of CAN controller. </p>
<p>States are divided into main states and additional error indicators. A CAN controller is always in exactly one main state. CAN bus errors are registered by the CAN hardware and collected by the driver. There is one error indicator (bit) per error type. If this IOCTL is triggered the error types which occured since the last call of this IOCTL are reported and thereafter the error indicators are cleared. See also <a class="el" href="group__rtcan.html#CAN_STATE">CAN controller states</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of <a class="el" href="group__rtcan.html#ga47a129d7188a7cd7b68fbf60ebbfd9e8">can_mode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="gaee74ae50c8ea0a6aee277c6f124a3866"></a><!-- doxytag: member="rtcan.h::SIOCGIFINDEX" ref="gaee74ae50c8ea0a6aee277c6f124a3866" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGIFINDEX&nbsp;&nbsp;&nbsp;defined_by_kernel_header_file</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get CAN interface index by name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). If <code>ifr_name</code> holds a valid CAN interface name <code>ifr_ifindex</code> will be filled with the corresponding interface index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcan__rtt_8c-example.html#a13">rtcan_rtt.c</a>, <a class="el" href="rtcanconfig_8c-example.html#a3">rtcanconfig.c</a>, <a class="el" href="rtcanrecv_8c-example.html#a13">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a14">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7c070037c218b40de849ebf4d299f977"></a><!-- doxytag: member="rtcan.h::SIOCSCANBAUDRATE" ref="ga7c070037c218b40de849ebf4d299f977" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANBAUDRATE&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x01, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set baud rate. </p>
<p>The baudrate must be specified in bits per second. The driver will try to calculate resonable CAN bit-timing parameters. You can use <a class="el" href="group__rtcan.html#ga4e9547dcb608fd0b8d5cf57f926e5176">SIOCSCANCUSTOMBITTIME</a> to set custom bit-timing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtcan.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</li>
<li>-EDOM : Baud rate not possible.</li>
<li>-EAGAIN: Request could not be successully fulfilled. Try again.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting the baud rate is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost.</dd></dl>
<p>Rescheduling: possible. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a4">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga26fa69d2cded6e172b96b4a6dc3798df"></a><!-- doxytag: member="rtcan.h::SIOCSCANCTRLMODE" ref="ga26fa69d2cded6e172b96b4a6dc3798df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANCTRLMODE&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x07, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set special controller modes. </p>
<p>Various special controller modes could be or'ed together (see <a class="el" href="group__rtcan.html#CAN_CTRLMODE">CAN_CTRLMODE</a> for further information).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#gaa1db20ee5ae4803157e38db4b6c6150b">can_ctrlmode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtcan.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</li>
<li>-EAGAIN: Request could not be successully fulfilled. Try again.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting special controller modes is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost.</dd></dl>
<p>Rescheduling: possible. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a17">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4e9547dcb608fd0b8d5cf57f926e5176"></a><!-- doxytag: member="rtcan.h::SIOCSCANCUSTOMBITTIME" ref="ga4e9547dcb608fd0b8d5cf57f926e5176" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANCUSTOMBITTIME&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x03, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set custom bit time parameter. </p>
<p>Custem-bit time could be defined in various formats (see struct <a class="el" href="structcan__bittime.html" title="Custom CAN bit-time definition.">can_bittime</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of struct <a class="el" href="structcan__bittime.html" title="Custom CAN bit-time definition.">can_bittime</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtcan.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</li>
<li>-EAGAIN: Request could not be successully fulfilled. Try again.</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting the bit-time is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost.</dd></dl>
<p>Rescheduling: possible. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a16">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga72b56a34fe466bca858b1f5f401e1076"></a><!-- doxytag: member="rtcan.h::SIOCSCANMODE" ref="ga72b56a34fe466bca858b1f5f401e1076" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANMODE&nbsp;&nbsp;&nbsp;_IOW(RTIOC_TYPE_CAN, 0x05, struct ifreq)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set operation mode of CAN controller. </p>
<p>See <a class="el" href="group__rtcan.html#CAN_MODE">CAN controller modes</a> for available modes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Pointer to interface request structure buffer (<code>struct ifreq</code> from linux/if.h). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtcan.html#ga47a129d7188a7cd7b68fbf60ebbfd9e8">can_mode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EAGAIN: (<a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>, <a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790">CAN_MODE_STOP</a>) Could not successfully set mode, hardware is busy. Try again.</li>
<li>-EINVAL: (<a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>) Cannot start controller, set baud rate first.</li>
<li>-ENETDOWN: (<a class="el" href="group__rtcan.html#ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e">CAN_MODE_SLEEP</a>) Cannot go into sleep mode because controller is stopped or bus off.</li>
<li>-EOPNOTSUPP: unknown mode</li>
</ul>
</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting a CAN controller into normal operation after a bus-off can take some time (128 occurrences of 11 consecutive recessive bits). In such a case, although this IOCTL will return immediately with success and <a class="el" href="group__rtcan.html#ga5b5f750db08d56f40489679f22236ef4">SIOCGCANSTATE</a> will report <a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67">CAN_STATE_ACTIVE</a>, bus-off recovery may still be in progress. <br/>
 If a controller is bus-off, setting it into stop mode will return no error but the controller remains bus-off.</dd></dl>
<p>Rescheduling: possible. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a18">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad981aa82a29d828882a2fb4c35c1cdd7"></a><!-- doxytag: member="rtcan.h::SOL_CAN_RAW" ref="gad981aa82a29d828882a2fb4c35c1cdd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_CAN_RAW&nbsp;&nbsp;&nbsp;103</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CAN socket levels. </p>
<p>Used for <a class="el" href="group__rtcan.html#Sockopts">Sockopts</a> for the particular protocols. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcan__rtt_8c-example.html#a14">rtcan_rtt.c</a>, <a class="el" href="rtcanrecv_8c-example.html#a15">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a12">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga95d9c00c42529e030dcc8d43a98127a2"></a><!-- doxytag: member="rtcan.h::can_filter_t" ref="ga95d9c00c42529e030dcc8d43a98127a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcan__filter.html">can_filter</a>  <a class="el" href="structcan__filter.html">can_filter_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filter for reception of CAN messages. </p>
<p>This filter works as follows: A received CAN ID is AND'ed bitwise with <code>can_mask</code> and then compared to <code>can_id</code>. This also includes the <a class="el" href="group__rtcan.html#ga5ae55ab3741140024858bd7b8762ea42">CAN_EFF_FLAG</a> and <a class="el" href="group__rtcan.html#gaf324d65226057755175038a15d9bbd75">CAN_RTR_FLAG</a> of <a class="el" href="group__rtcan.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a>. If this comparison is true, the message will be received by the socket. The logic can be inverted with the <code>can_id</code> flag <a class="el" href="group__rtcan.html#ga5cb484fa2d90489f6b4e7a77c254c59f">CAN_INV_FILTER</a> :</p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (can_id &amp; <a class="code" href="group__rtcan.html#ga5cb484fa2d90489f6b4e7a77c254c59f" title="Invert CAN filter definition, only valid in struct can_filter.">CAN_INV_FILTER</a>) {
    <span class="keywordflow">if</span> ((received_can_id &amp; can_mask) != (can_id &amp; ~CAN_INV_FILTER))
       accept-message;
 } <span class="keywordflow">else</span> {
    <span class="keywordflow">if</span> ((received_can_id &amp; can_mask) == can_id)
       accept-message;
 }
</pre></div><p>Multiple filters can be arranged in a filter list and set with <a class="el" href="group__rtcan.html#Sockopts">Sockopts</a>. If one of these filters matches a CAN ID upon reception of a CAN frame, this frame is accepted. </p>

</div>
</div>
<a class="anchor" id="gace340cdd98cbfd2525c9d6b23cdd2188"></a><!-- doxytag: member="rtcan.h::can_frame_t" ref="gace340cdd98cbfd2525c9d6b23cdd2188" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcan__frame.html">can_frame</a>  <a class="el" href="structcan__frame.html">can_frame_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raw CAN frame. </p>
<p>Central structure for receiving and sending CAN frames. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga42c4f551b57f47d4e004c02505a01f71"></a><!-- doxytag: member="rtcan.h::CAN_BITTIME_TYPE" ref="ga42c4f551b57f47d4e004c02505a01f71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtcan.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported CAN bit-time types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga42c4f551b57f47d4e004c02505a01f71a160d7c514df2477f8016ed1bf5a6709f"></a><!-- doxytag: member="CAN_BITTIME_STD" ref="gga42c4f551b57f47d4e004c02505a01f71a160d7c514df2477f8016ed1bf5a6709f" args="" -->CAN_BITTIME_STD</em>&nbsp;</td><td>
<p>Standard bit-time definition according to Bosch. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga42c4f551b57f47d4e004c02505a01f71ae164a942c698440f2548bd82fea33e55"></a><!-- doxytag: member="CAN_BITTIME_BTR" ref="gga42c4f551b57f47d4e004c02505a01f71ae164a942c698440f2548bd82fea33e55" args="" -->CAN_BITTIME_BTR</em>&nbsp;</td><td>
<p>Hardware-specific BTR bit-time definition. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gac0d6cdda2cf4abb51116b86bc99acf99"></a><!-- doxytag: member="rtcan.h::CAN_MODE" ref="gac0d6cdda2cf4abb51116b86bc99acf99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtcan.html#gac0d6cdda2cf4abb51116b86bc99acf99">CAN_MODE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790"></a><!-- doxytag: member="CAN_MODE_STOP" ref="ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790" args="" -->CAN_MODE_STOP</em>&nbsp;</td><td>
<p>Set controller in Stop mode (no reception / transmission possible) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6"></a><!-- doxytag: member="CAN_MODE_START" ref="ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6" args="" -->CAN_MODE_START</em>&nbsp;</td><td>
<p>Set controller into normal operation. <br/>
 Coming from stopped mode or bus off, the controller begins with no errors in <a class="el" href="group__rtcan.html#gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67">CAN_STATE_ACTIVE</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e"></a><!-- doxytag: member="CAN_MODE_SLEEP" ref="ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e" args="" -->CAN_MODE_SLEEP</em>&nbsp;</td><td>
<p>Set controller into Sleep mode. <br/>
 This is only possible if the controller is not stopped or bus-off. <br/>
 Notice that sleep mode will only be entered when there is no bus activity. If the controller detects bus activity while "sleeping" it will go into operating mode again. <br/>
 To actively leave sleep mode again trigger <code>CAN_MODE_START</code>. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8680f5710e1a13d553067cc32c86226b"></a><!-- doxytag: member="rtcan.h::CAN_STATE" ref="ga8680f5710e1a13d553067cc32c86226b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtcan.html#ga8680f5710e1a13d553067cc32c86226b">CAN_STATE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67"></a><!-- doxytag: member="CAN_STATE_ACTIVE" ref="gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67" args="" -->CAN_STATE_ACTIVE</em>&nbsp;</td><td>
<p>CAN controller is error active. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba8e8ffc38c3886c8ab4b7a6ebd24db2e1"></a><!-- doxytag: member="CAN_STATE_BUS_WARNING" ref="gga8680f5710e1a13d553067cc32c86226ba8e8ffc38c3886c8ab4b7a6ebd24db2e1" args="" -->CAN_STATE_BUS_WARNING</em>&nbsp;</td><td>
<p>CAN controller is error active, warning level is reached. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba16806979589ee8f20ee84c767903b667"></a><!-- doxytag: member="CAN_STATE_BUS_PASSIVE" ref="gga8680f5710e1a13d553067cc32c86226ba16806979589ee8f20ee84c767903b667" args="" -->CAN_STATE_BUS_PASSIVE</em>&nbsp;</td><td>
<p>CAN controller is error passive. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba679935a8710667fcb99423d217cd9959"></a><!-- doxytag: member="CAN_STATE_BUS_OFF" ref="gga8680f5710e1a13d553067cc32c86226ba679935a8710667fcb99423d217cd9959" args="" -->CAN_STATE_BUS_OFF</em>&nbsp;</td><td>
<p>CAN controller went into Bus Off. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226bacc4b4039f38316b01662d775eeb981ff"></a><!-- doxytag: member="CAN_STATE_SCANNING_BAUDRATE" ref="gga8680f5710e1a13d553067cc32c86226bacc4b4039f38316b01662d775eeb981ff" args="" -->CAN_STATE_SCANNING_BAUDRATE</em>&nbsp;</td><td>
<p>CAN controller is scanning to get the baudrate. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba644e7a441f2e607b93528d3128508cc8"></a><!-- doxytag: member="CAN_STATE_STOPPED" ref="gga8680f5710e1a13d553067cc32c86226ba644e7a441f2e607b93528d3128508cc8" args="" -->CAN_STATE_STOPPED</em>&nbsp;</td><td>
<p>CAN controller is in stopped mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba2bb74d448dac491e9cfcc7f7bcc14857"></a><!-- doxytag: member="CAN_STATE_SLEEPING" ref="gga8680f5710e1a13d553067cc32c86226ba2bb74d448dac491e9cfcc7f7bcc14857" args="" -->CAN_STATE_SLEEPING</em>&nbsp;</td><td>
<p>CAN controller is in Sleep mode. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 10 2012 20:41:25 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
